{"version":3,"sources":["../../node_modules/tslib/tslib.es6.js","../esm2015/src/lib/directives/wizard-step-symbol.directive.ts","../esm2015/src/lib/directives/wizard-step-title.directive.ts","../esm2015/src/lib/util/wizard-step.interface.ts","../esm2015/src/lib/util/wizard-completion-step.interface.ts","../esm2015/src/lib/util/moving-direction.enum.ts","../esm2015/src/lib/components/wizard-completion-step.component.ts","../esm2015/src/lib/navigation/base-navigation-mode.interface.ts","../esm2015/src/lib/navigation/configurable-navigation-mode.ts","../esm2015/src/lib/components/wizard.component.ts","../esm2015/src/lib/components/wizard-navigation-bar.component.ts","../esm2015/src/lib/components/wizard-step.component.ts","../esm2015/src/lib/directives/enable-back-links.directive.ts","../esm2015/src/lib/util/step-id.interface.ts","../esm2015/src/lib/util/step-index.interface.ts","../esm2015/src/lib/util/step-offset.interface.ts","../esm2015/src/lib/directives/go-to-step.directive.ts","../esm2015/src/lib/directives/next-step.directive.ts","../esm2015/src/lib/directives/optional-step.directive.ts","../esm2015/src/lib/directives/previous-step.directive.ts","../esm2015/src/lib/directives/reset-wizard.directive.ts","../esm2015/src/lib/directives/selected-step.directive.ts","../esm2015/src/lib/directives/wizard-completion-step.directive.ts","../esm2015/src/lib/directives/wizard-step.directive.ts","../esm2015/src/lib/directives/navigation-mode.directive.ts","../esm2015/src/lib/directives/completed-step.directive.ts","../src/lib/archwizard.module.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","__","this","constructor","create","__read","o","n","m","Symbol","iterator","r","e","i","ar","next","done","push","value","error","__spread","arguments","length","concat","templateRef","Directive","args","selector","TemplateRef","WizardStep","navigationSymbol","symbol","selected","completed","initiallyCompleted","editing","defaultSelected","optional","canEnter","canExit","stepEnter","EventEmitter","stepExit","defineProperty","canTransitionStep","condition","direction","Promise","resolve","Function","reject","Error","enter","emit","exit","canEnterStep","canExitStep","ContentChild","WizardStepTitleDirective","WizardStepSymbolDirective","Input","Output","HostBinding","WizardCompletionStep","_this","_super","apply","MovingDirection","WizardCompletionStepComponent","Component","template","providers","provide","useExisting","forwardRef","BaseNavigationMode","canGoToStep","wizard","destinationIndex","hasStep","movingDirection","getMovingDirection","then","previous","canTransitionToStep","currentStep","getStepAtIndex","isNavigable","goToStep","preFinalize","postFinalize","navigationAllowed","transition","wasCompleted","Stay","currentStepIndex","reset","ensureCanReset","wizardSteps","forEach","step","defaultStepIndex","Forwards","ConfigurableNavigationMode","navigateBackward","navigateForward","filter","index","every","destinationStep","WizardComponent","navBarLocation","navBarLayout","navBarDirection","_defaultStepIndex","disableNavigationBar","_navigation","_wizardSteps","foundDefaultStep","find","getIndexOfStep","ngAfterContentInit","wizardStepsQueryList","changes","subscribe","changedWizardSteps","updateWizardSteps","toArray","setTimeout","indexOf","navigation","stepIndex","hasPreviousStep","hasNextStep","isLastStep","getIndexOfStepWithId","stepId","findIndex","Backwards","goToPreviousStep","goToNextStep","ContentChildren","descendants","WizardNavigationBarComponent","slice","reverse","isCurrent","wizardStep","isEditing","isDone","isOptional","isCompleted","WizardStepComponent","EnableBackLinksDirective","completionStep","ngOnInit","isStepId","isStepIndex","isStepOffset","decorators","type","Host","GoToStepDirective","emitter","targetStep","stepOffset","onClick","Optional","HostListener","NextStepDirective","OptionalStepDirective","PreviousStepDirective","ResetWizardDirective","finalize","SelectedStepDirective","WizardCompletionStepDirective","WizardStepDirective","NavigationModeDirective","ngOnChanges","getNavigationMode","awNavigationMode","CompletedStepDirective","ArchwizardModule","forRoot","ngModule","NgModule","declarations","imports","CommonModule","exports"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import {Directive, TemplateRef} from '@angular/core';\n\n/**\n * The `awWizardStepSymbol` directive can be used as an alternative to the `navigationSymbol` input of a [[WizardStep]]\n * to define the step symbol inside the navigation bar.  This way step symbol may contain arbitrary content.\n *\n * ### Syntax\n *\n * ```html\n * <ng-template awWizardStepSymbol>\n *     ...\n * </ng-template>\n * ```\n */\n@Directive({\n  selector: 'ng-template[awStepSymbol], ng-template[awWizardStepSymbol]'\n})\nexport class WizardStepSymbolDirective {\n  /**\n   * Constructor\n   *\n   * @param templateRef A reference to the content of the `ng-template` that contains this [[WizardStepSymbolDirective]]\n   */\n  constructor(public templateRef: TemplateRef<any>) {\n  }\n}\n","import {Directive, TemplateRef} from '@angular/core';\n\n/**\n * The `awWizardStepTitle` directive can be used as an alternative to the `stepTitle` input of a [[WizardStep]]\n * to define the content of a step title inside the navigation bar.\n * This step title can be freely created and can contain more than only plain text\n *\n * ### Syntax\n *\n * ```html\n * <ng-template awWizardStepTitle>\n *     ...\n * </ng-template>\n * ```\n *\n * @author Marc Arndt\n */\n@Directive({\n  selector: 'ng-template[awStepTitle], ng-template[awWizardStepTitle]'\n})\nexport class WizardStepTitleDirective {\n  /**\n   * Constructor\n   *\n   * @param templateRef A reference to the content of the `ng-template` that contains this [[WizardStepTitleDirective]]\n   */\n  constructor(public templateRef: TemplateRef<any>) {\n  }\n}\n","import { ContentChild, EventEmitter, HostBinding, Input, Output, Directive } from '@angular/core';\nimport {WizardStepSymbolDirective} from '../directives/wizard-step-symbol.directive';\nimport {WizardStepTitleDirective} from '../directives/wizard-step-title.directive';\nimport {MovingDirection} from './moving-direction.enum';\nimport {NavigationSymbol} from './navigation-symbol.interface';\n\n/**\n * Basic functionality every type of wizard step needs to provide\n *\n * @author Marc Arndt\n */\n@Directive()\n/* tslint:disable-next-line directive-class-suffix */\nexport abstract class WizardStep {\n  /**\n   * A step title property, which contains the visible header title of the step.\n   * This title is then shown inside the navigation bar.\n   * Compared to `stepTitle` this property can contain any html content and not only plain text\n   */\n  @ContentChild(WizardStepTitleDirective)\n  public stepTitleTemplate: WizardStepTitleDirective;\n\n  /**\n   * A step symbol property that, if defined, overrides `navigationSymbol`.\n   * Allows to display arbitrary content as a step symbol instead of plain text.\n   */\n  @ContentChild(WizardStepSymbolDirective)\n  public stepSymbolTemplate: WizardStepSymbolDirective;\n\n  /**\n   * A step id, unique to the step\n   */\n  @Input()\n  public stepId: string;\n\n  /**\n   * A step title property, which contains the visible header title of the step.\n   * This title is only shown inside the navigation bar, if `stepTitleTemplate` is not defined or null.\n   */\n  @Input()\n  public stepTitle: string;\n\n  /**\n   * A symbol property, which contains an optional symbol for the step inside the navigation bar.\n   * Takes effect when `stepSymbolTemplate` is not defined or null.\n   */\n  @Input()\n  public navigationSymbol: NavigationSymbol = {symbol: ''};\n\n  /**\n   * A boolean describing if the wizard step is currently selected\n   */\n  public selected = false;\n\n  /**\n   * A boolean describing if the wizard step has been completed\n   */\n  public completed = false;\n\n  /**\n   * A boolean describing if the wizard step is shown as completed when the wizard is presented to the user\n   *\n   * Users will typically use `CompletedStepDirective` to set this flag\n   */\n  public initiallyCompleted = false;\n\n  /**\n   * A boolean describing if the wizard step is being edited after being competed\n   *\n   * This flag can only be true when `selected` is true.\n   */\n  public editing = false;\n\n  /**\n   * A boolean describing, if the wizard step should be selected by default, i.e. after the wizard has been initialized as the initial step\n   */\n  public defaultSelected = false;\n\n  /**\n   * A boolean describing if the wizard step is an optional step\n   */\n  public optional = false;\n\n  /**\n   * A function or boolean deciding, if this step can be entered\n   */\n  @Input()\n  public canEnter: ((direction: MovingDirection) => boolean) | ((direction: MovingDirection) => Promise<boolean>) | boolean = true;\n\n  /**\n   * A function or boolean deciding, if this step can be exited\n   */\n  @Input()\n  public canExit: ((direction: MovingDirection) => boolean) | ((direction: MovingDirection) => Promise<boolean>) | boolean = true;\n\n  /**\n   * This [[EventEmitter]] is called when the step is entered.\n   * The bound method should be used to do initialization work.\n   */\n  @Output()\n  public stepEnter: EventEmitter<MovingDirection> = new EventEmitter<MovingDirection>();\n\n  /**\n   * This [[EventEmitter]] is called when the step is exited.\n   * The bound method can be used to do cleanup work.\n   */\n  @Output()\n  public stepExit: EventEmitter<MovingDirection> = new EventEmitter<MovingDirection>();\n\n  /**\n   * Returns true if this wizard step should be visible to the user.\n   * If the step should be visible to the user false is returned, otherwise true\n   */\n  @HostBinding('hidden')\n  public get hidden(): boolean {\n    return !this.selected;\n  }\n\n  /**\n   * This method returns true, if this wizard step can be transitioned with a given direction.\n   * Transitioned in this case means either entered or exited, depending on the given `condition` parameter.\n   *\n   * @param condition A condition variable, deciding if the step can be transitioned\n   * @param direction The direction in which this step should be transitioned\n   * @returns A [[Promise]] containing `true`, if this step can transitioned in the given direction\n   * @throws An `Error` is thrown if `condition` is neither a function nor a boolean\n   */\n  private static canTransitionStep(condition: ((direction: MovingDirection) => boolean) |\n                                     ((direction: MovingDirection) => Promise<boolean>) |\n                                     boolean,\n                                   direction: MovingDirection): Promise<boolean> {\n    if (typeof(condition) === typeof(true)) {\n      return Promise.resolve(condition as boolean);\n    } else if (condition instanceof Function) {\n      return Promise.resolve(condition(direction));\n    } else {\n      return Promise.reject(new Error(`Input value '${condition}' is neither a boolean nor a function`));\n    }\n  }\n\n  /**\n   * A function called when the step is entered\n   *\n   * @param direction The direction in which the step is entered\n   */\n  public enter(direction: MovingDirection): void {\n    this.stepEnter.emit(direction);\n  }\n\n  /**\n   * A function called when the step is exited\n   *\n   * @param direction The direction in which the step is exited\n   */\n  public exit(direction: MovingDirection) {\n    this.stepExit.emit(direction);\n  }\n\n  /**\n   * This method returns true, if this wizard step can be entered from the given direction.\n   * Because this method depends on the value `canEnter`, it will throw an error, if `canEnter` is neither a boolean\n   * nor a function.\n   *\n   * @param direction The direction in which this step should be entered\n   * @returns A [[Promise]] containing `true`, if the step can be entered in the given direction, false otherwise\n   * @throws An `Error` is thrown if `anEnter` is neither a function nor a boolean\n   */\n  public canEnterStep(direction: MovingDirection): Promise<boolean> {\n    return WizardStep.canTransitionStep(this.canEnter, direction);\n  }\n\n  /**\n   * This method returns true, if this wizard step can be exited into given direction.\n   * Because this method depends on the value `canExit`, it will throw an error, if `canExit` is neither a boolean\n   * nor a function.\n   *\n   * @param direction The direction in which this step should be left\n   * @returns A [[Promise]] containing `true`, if the step can be exited in the given direction, false otherwise\n   * @throws An `Error` is thrown if `canExit` is neither a function nor a boolean\n   */\n  public canExitStep(direction: MovingDirection): Promise<boolean> {\n    return WizardStep.canTransitionStep(this.canExit, direction);\n  }\n}\n","import {EventEmitter, Directive} from '@angular/core';\nimport {WizardStep} from './wizard-step.interface';\nimport {MovingDirection} from './moving-direction.enum';\n\n/**\n * Basic functionality every wizard completion step needs to provide\n *\n * @author Marc Arndt\n */\n@Directive()\n/* tslint:disable-next-line directive-class-suffix */\nexport abstract class WizardCompletionStep extends WizardStep {\n  /**\n   * @inheritDoc\n   */\n  public stepExit = new EventEmitter<MovingDirection>();\n\n  /**\n   * @inheritDoc\n   */\n  public canExit: ((direction: MovingDirection) => boolean) | boolean = false;\n\n  /**\n   * @inheritDoc\n   */\n  public enter(direction: MovingDirection): void {\n    this.completed = true;\n    this.stepEnter.emit(direction);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public exit(direction: MovingDirection): void {\n    // set this completion step as incomplete (unless it happens to be initiallyCompleted)\n    this.completed = this.initiallyCompleted;\n    this.stepExit.emit(direction);\n  }\n}\n","/**\n * The direction in which a step transition was made\n *\n * @author Marc Arndt\n */\n\n/**\n * This enum contains the different possible moving directions in which a wizard can be traversed\n *\n * @author Marc Arndt\n */\nexport enum MovingDirection {\n  /**\n   * A forward step transition\n   */\n  Forwards,\n  /**\n   * A backward step transition\n   */\n  Backwards,\n  /**\n   * No step transition was done\n   */\n  Stay\n}\n","import {Component, forwardRef} from '@angular/core';\nimport {WizardCompletionStep} from '../util/wizard-completion-step.interface';\nimport {WizardStep} from '../util/wizard-step.interface';\n\n/**\n * The `aw-wizard-completion-step` component can be used to define a completion/success step at the end of your wizard\n * After a `aw-wizard-completion-step` has been entered, it has the characteristic that the user is blocked from\n * leaving it again to a previous step.\n * In addition entering a `aw-wizard-completion-step` automatically sets the `aw-wizard` and all steps inside the `aw-wizard`\n * as completed.\n *\n * ### Syntax\n *\n * ```html\n * <aw-wizard-completion-step [stepTitle]=\"title of the wizard step\"\n *    [navigationSymbol]=\"{ symbol: 'navigation symbol', fontFamily: 'navigation symbol font family' }\"\n *    (stepEnter)=\"event emitter to be called when the wizard step is entered\"\n *    (stepExit)=\"event emitter to be called when the wizard step is exited\">\n *    ...\n * </aw-wizard-completion-step>\n * ```\n *\n * ### Example\n *\n * ```html\n * <aw-wizard-completion-step stepTitle=\"Step 1\" [navigationSymbol]=\"{ symbol: '1' }\">\n *    ...\n * </aw-wizard-completion-step>\n * ```\n *\n * With a navigation symbol from the `font-awesome` font:\n *\n * ```html\n * <aw-wizard-completion-step stepTitle=\"Step 1\" [navigationSymbol]=\"{ symbol: '&#xf1ba;', fontFamily: 'FontAwesome' }\">\n *    ...\n * </aw-wizard-completion-step>\n * ```\n *\n * @author Marc Arndt\n */\n@Component({\n  selector: 'aw-wizard-completion-step',\n  templateUrl: 'wizard-completion-step.component.html',\n  providers: [\n    {provide: WizardStep, useExisting: forwardRef(() => WizardCompletionStepComponent)},\n    {provide: WizardCompletionStep, useExisting: forwardRef(() => WizardCompletionStepComponent)}\n  ]\n})\nexport class WizardCompletionStepComponent extends WizardCompletionStep {\n}\n","import {EventEmitter} from '@angular/core';\nimport {MovingDirection} from '../util/moving-direction.enum';\nimport {NavigationMode} from './navigation-mode.interface';\nimport {WizardComponent} from '../components/wizard.component';\n\n/**\n * Base implementation of [[NavigationMode]]\n *\n * Note: Built-in [[NavigationMode]] classes should be stateless, allowing the library user to easily create\n * an instance of a particular [[NavigationMode]] class and pass it to `<aw-wizard [navigationMode]=\"...\">`.\n *\n * @author Marc Arndt\n */\nexport abstract class BaseNavigationMode implements NavigationMode {\n\n  /**\n   * Checks, whether a wizard step, as defined by the given destination index, can be transitioned to.\n   *\n   * This method controls navigation by [[goToStep]], [[goToPreviousStep]], and [[goToNextStep]] directives.\n   * Navigation by navigation bar is governed by [[isNavigable]].\n   *\n   * In this implementation, a destination wizard step can be entered if:\n   * - it exists\n   * - the current step can be exited in the direction of the destination step\n   * - the destination step can be entered in the direction from the current step\n   *\n   * Subclasses can impose additional restrictions, see [[canTransitionToStep]].\n   *\n   * @param wizard The wizard component to operate on\n   * @param destinationIndex The index of the destination step\n   * @returns A [[Promise]] containing `true`, if the destination step can be transitioned to and `false` otherwise\n   */\n  public canGoToStep(wizard: WizardComponent, destinationIndex: number): Promise<boolean> {\n    const hasStep = wizard.hasStep(destinationIndex);\n\n    const movingDirection = wizard.getMovingDirection(destinationIndex);\n\n    const canExitCurrentStep = (previous: boolean) => {\n      return previous && wizard.currentStep.canExitStep(movingDirection);\n    };\n\n    const canEnterDestinationStep = (previous: boolean) => {\n      return previous && wizard.getStepAtIndex(destinationIndex).canEnterStep(movingDirection);\n    };\n\n    const canTransitionToStep = (previous: boolean) => {\n      return previous && this.canTransitionToStep(wizard, destinationIndex);\n    };\n\n    return Promise.resolve(hasStep)\n      .then(canTransitionToStep)\n      // Apply user-defined checks at the end.  They can involve user interaction\n      // which is better to be avoided if navigation mode does not actually allow the transition\n      // (`canTransitionToStep` returns `false`).\n      .then(canExitCurrentStep)\n      .then(canEnterDestinationStep);\n  }\n\n  /**\n   * Imposes additional restrictions for `canGoToStep` in current navigation mode.\n   *\n   * The base implementation allows transition iff the given step is navigable from the navigation bar (see `isNavigable`).\n   * However, in some navigation modes `canTransitionToStep` can be more relaxed to allow navigation to certain steps\n   * by previous/next buttons, but not using the navigation bar.\n   *\n   * @param wizard The wizard component to operate on\n   * @param destinationIndex The index of the destination step\n   * @returns `true`, if the destination step can be transitioned to and `false` otherwise\n   */\n  protected canTransitionToStep(wizard: WizardComponent, destinationIndex: number): boolean {\n    return this.isNavigable(wizard, destinationIndex);\n  }\n\n  /**\n   * Tries to transition to the wizard step, as denoted by the given destination index.\n   *\n   * When entering the destination step, the following actions are done:\n   * - the old current step is set as completed\n   * - the old current step is set as unselected\n   * - the old current step is exited\n   * - the destination step is set as selected\n   * - the destination step is entered\n   *\n   * When the destination step couldn't be entered, the following actions are done:\n   * - the current step is exited and entered in the direction `MovingDirection.Stay`\n   *\n   * @param wizard The wizard component to operate on\n   * @param destinationIndex The index of the destination wizard step, which should be entered\n   * @param preFinalize An event emitter, to be called before the step has been transitioned\n   * @param postFinalize An event emitter, to be called after the step has been transitioned\n   */\n  public goToStep(\n    wizard: WizardComponent,\n    destinationIndex: number,\n    preFinalize?: EventEmitter<void>,\n    postFinalize?: EventEmitter<void>): void {\n\n    this.canGoToStep(wizard, destinationIndex).then(navigationAllowed => {\n      if (navigationAllowed) {\n        // the current step can be exited in the given direction\n        const movingDirection: MovingDirection = wizard.getMovingDirection(destinationIndex);\n\n        /* istanbul ignore if */\n        if (preFinalize) {\n          preFinalize.emit();\n        }\n\n        // leave current step\n        wizard.currentStep.completed = true;\n        wizard.currentStep.exit(movingDirection);\n        wizard.currentStep.editing = false;\n        wizard.currentStep.selected = false;\n\n        this.transition(wizard, destinationIndex);\n\n        // remember if the next step is already completed before entering it to properly set `editing` flag\n        const wasCompleted = wizard.completed || wizard.currentStep.completed;\n\n        // go to next step\n        wizard.currentStep.enter(movingDirection);\n        wizard.currentStep.selected = true;\n        if (wasCompleted) {\n          wizard.currentStep.editing = true;\n        }\n\n        /* istanbul ignore if */\n        if (postFinalize) {\n          postFinalize.emit();\n        }\n      } else {\n        // if the current step can't be left, reenter the current step\n        wizard.currentStep.exit(MovingDirection.Stay);\n        wizard.currentStep.enter(MovingDirection.Stay);\n      }\n    });\n  }\n\n  /**\n   * Transitions the wizard to the given step index.\n   *\n   * Can perform additional actions in particular navigation mode implementations.\n   *\n   * @param wizard The wizard component to operate on\n   * @param destinationIndex The index of the destination wizard step\n   */\n  protected transition(wizard: WizardComponent, destinationIndex: number): void {\n    wizard.currentStepIndex = destinationIndex;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public abstract isNavigable(WizardComponent: WizardComponent, destinationIndex: number): boolean;\n\n  /**\n   * Resets the state of this wizard.\n   *\n   * A reset transitions the wizard automatically to the first step and sets all steps as incomplete.\n   * In addition the whole wizard is set as incomplete.\n   *\n   * @param wizard The wizard component to operate on\n   */\n  public reset(wizard: WizardComponent): void {\n    this.ensureCanReset(wizard);\n\n    // reset the step internal state\n    wizard.wizardSteps.forEach(step => {\n      step.completed = step.initiallyCompleted;\n      step.selected = false;\n      step.editing = false;\n    });\n\n    // set the first step as the current step\n    wizard.currentStepIndex = wizard.defaultStepIndex;\n    wizard.currentStep.selected = true;\n    wizard.currentStep.enter(MovingDirection.Forwards);\n  }\n\n  /**\n   * Checks if wizard configuration allows to perform reset.\n   *\n   * A check failure is indicated by throwing an `Error` with the message discribing the discovered misconfiguration issue.\n   *\n   * Can include additional checks in particular navigation mode implementations.\n   *\n   * @param wizard The wizard component to operate on\n   * @throws An `Error` is thrown, if a micconfiguration issue is discovered.\n   */\n  protected ensureCanReset(wizard: WizardComponent): void {\n    // the wizard doesn't contain a step with the default step index\n    if (!wizard.hasStep(wizard.defaultStepIndex)) {\n      throw new Error(`The wizard doesn't contain a step with index ${wizard.defaultStepIndex}`);\n    }\n  }\n}\n","import {BaseNavigationMode} from './base-navigation-mode.interface';\nimport {WizardComponent} from '../components/wizard.component';\nimport {WizardCompletionStep} from '../util/wizard-completion-step.interface';\n\n/**\n * The default navigation mode used by [[WizardComponent]] and [[NavigationModeDirective]].\n *\n * It is parameterized with two navigation policies passed to constructor:\n *\n * - [[navigateBackward]] policy controls whether wizard steps before the current step are navigable:\n *\n *   - `\"deny\"` -- the steps are not navigable\n *   - `\"allow\"` -- the steps are navigable\n *   - If the corresponding constructor argument is omitted or is `null` or `undefined`,\n *     then the default value is applied which is `\"deny\"`\n *\n * - [[navigateForward]] policy controls whether wizard steps after the current step are navigable:\n *\n *   - `\"deny\"` -- the steps are not navigable\n *   - `\"allow\"` -- the steps are navigable\n *   - `\"visited\"` -- a step is navigable iff it was already visited before\n *   - If the corresponding constructor argument is omitted or is `null` or `undefined`,\n *     then the default value is applied which is `\"allow\"`\n */\nexport class ConfigurableNavigationMode extends BaseNavigationMode {\n\n  /**\n   * Constructor\n   *\n   * @param navigateBackward Controls whether wizard steps before the current step are navigable\n   * @param navigateForward Controls whether wizard steps before the current step are navigable\n   */\n  constructor(\n    private navigateBackward: 'allow'|'deny'|null = null,\n    private navigateForward: 'allow'|'deny'|'visited'|null = null,\n  ) {\n    super();\n    this.navigateBackward = this.navigateBackward || 'allow';\n    this.navigateForward = this.navigateForward || 'deny';\n  }\n\n  /**\n   * @inheritDoc\n   */\n  protected canTransitionToStep(wizard: WizardComponent, destinationIndex: number): boolean {\n    // if the destination step can be navigated to using the navigation bar,\n    // it should be accessible with [goToStep] as well\n    if (this.isNavigable(wizard, destinationIndex)) {\n      return true;\n    }\n\n    // navigation with [goToStep] is permitted if all previous steps\n    // to the destination step have been completed or are optional\n    return wizard.wizardSteps\n        .filter((step, index) => index < destinationIndex && index !== wizard.currentStepIndex)\n        .every(step => step.completed || step.optional);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  protected transition(wizard: WizardComponent, destinationIndex: number): void {\n    if (this.navigateForward === 'deny') {\n      // set all steps after the destination step to incomplete\n      wizard.wizardSteps\n        .filter((step, index) => wizard.currentStepIndex > destinationIndex && index > destinationIndex)\n        .forEach(step => step.completed = false);\n    }\n\n    super.transition(wizard, destinationIndex);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public isNavigable(wizard: WizardComponent, destinationIndex: number): boolean {\n    // Check if the destination step can be navigated to\n    const destinationStep = wizard.getStepAtIndex(destinationIndex);\n    if (destinationStep instanceof WizardCompletionStep) {\n      // A completion step can only be entered, if all previous steps have been completed, are optional, or selected\n      const previousStepsCompleted = wizard.wizardSteps\n        .filter((step, index) => index < destinationIndex)\n        .every(step => step.completed || step.optional || step.selected);\n      if (!previousStepsCompleted) {\n        return false;\n      }\n    }\n\n    // Apply navigation pocicies\n    if (destinationIndex < wizard.currentStepIndex) {\n      // If the destination step is before current, apply the `navigateBackward` policy\n      switch (this.navigateBackward) {\n        case 'allow': return true;\n        case 'deny': return false;\n        default:\n          throw new Error(`Invalid value for navigateBackward: ${this.navigateBackward}`);\n      }\n    } else if (destinationIndex > wizard.currentStepIndex) {\n      // If the destination step is after current, apply the `navigateForward` policy\n      switch (this.navigateForward) {\n        case 'allow': return true;\n        case 'deny': return false;\n        case 'visited': return destinationStep.completed;\n        default:\n          throw new Error(`Invalid value for navigateForward: ${this.navigateForward}`);\n      }\n    } else {\n      // Re-entering the current step is not allowed\n      return false;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  protected ensureCanReset(wizard: WizardComponent): void {\n    super.ensureCanReset(wizard);\n\n    // the default step is a completion step and the wizard contains more than one step\n    const defaultWizardStep = wizard.getStepAtIndex(wizard.defaultStepIndex);\n    const defaultCompletionStep = defaultWizardStep instanceof WizardCompletionStep;\n    if (defaultCompletionStep && wizard.wizardSteps.length !== 1) {\n      throw new Error(`The default step index ${wizard.defaultStepIndex} references a completion step`);\n    }\n  }\n}\n","import {\n  AfterContentInit,\n  Component,\n  ContentChildren,\n  HostBinding,\n  Input,\n  QueryList,\n  EventEmitter,\n} from '@angular/core';\nimport {NavigationMode} from '../navigation/navigation-mode.interface';\nimport {WizardStep} from '../util/wizard-step.interface';\nimport {MovingDirection} from '../util/moving-direction.enum';\nimport {ConfigurableNavigationMode} from '../navigation/configurable-navigation-mode';\n\n/**\n * The `aw-wizard` component defines the root component of a wizard.\n * Through the setting of input parameters for the `aw-wizard` component it's possible to change the location and size\n * of its navigation bar.\n *\n * ### Syntax\n * ```html\n * <aw-wizard [navBarLocation]=\"location of navigation bar\" [navBarLayout]=\"layout of navigation bar\">\n *     ...\n * </aw-wizard>\n * ```\n *\n * ### Example\n *\n * Without completion step:\n *\n * ```html\n * <aw-wizard navBarLocation=\"top\" navBarLayout=\"small\">\n *     <aw-wizard-step>...</aw-wizard-step>\n *     <aw-wizard-step>...</aw-wizard-step>\n * </aw-wizard>\n * ```\n *\n * With completion step:\n *\n * ```html\n * <aw-wizard navBarLocation=\"top\" navBarLayout=\"small\">\n *     <aw-wizard-step>...</aw-wizard-step>\n *     <aw-wizard-step>...</aw-wizard-step>\n *     <aw-wizard-completion-step>...</aw-wizard-completion-step>\n * </aw-wizard>\n * ```\n *\n * @author Marc Arndt\n */\n@Component({\n  selector: 'aw-wizard',\n  templateUrl: 'wizard.component.html',\n})\nexport class WizardComponent implements AfterContentInit {\n  /**\n   * A QueryList containing all [[WizardStep]]s inside this wizard\n   */\n  @ContentChildren(WizardStep, { descendants: true })\n  public wizardStepsQueryList: QueryList<WizardStep>;\n\n  /**\n   * The location of the navigation bar inside the wizard.\n   * This location can be either top, bottom, left or right\n   */\n  @Input()\n  public navBarLocation = 'top';\n\n  /**\n   * The layout of the navigation bar inside the wizard.\n   * The layout can be either small, large-filled, large-empty or large-symbols\n   */\n  @Input()\n  public navBarLayout = 'small';\n\n  /**\n   * The direction in which the steps inside the navigation bar should be shown.\n   * The direction can be either `left-to-right` or `right-to-left`\n   */\n  @Input()\n  public navBarDirection = 'left-to-right';\n\n  /**\n   * The initially selected step, represented by its index\n   * Beware: This initial default is only used if no wizard step has been enhanced with the `selected` directive\n   */\n  @Input()\n  public get defaultStepIndex(): number {\n    // This value can be either:\n    // - the index of a wizard step with a `selected` directive, or\n    // - the default step index, set in the [[WizardComponent]]\n\n    const foundDefaultStep = this.wizardSteps.find(step => step.defaultSelected);\n\n    if (foundDefaultStep) {\n      return this.getIndexOfStep(foundDefaultStep);\n    } else {\n      return this._defaultStepIndex;\n    }\n  }\n  public set defaultStepIndex(defaultStepIndex: number) {\n    this._defaultStepIndex = defaultStepIndex;\n  }\n  private _defaultStepIndex = 0;\n\n  /**\n   * True, if the navigation bar shouldn't be used for navigating\n   */\n  @Input()\n  public disableNavigationBar = false;\n\n  /**\n   * The navigation mode used to navigate inside the wizard\n   *\n   * For outside access, use the [[navigation]] getter.\n   */\n  private _navigation: NavigationMode = new ConfigurableNavigationMode();\n\n  /**\n   * An array representation of all wizard steps belonging to this model\n   *\n   * For outside access, use the [[wizardSteps]] getter.\n   */\n  private _wizardSteps: WizardStep[] = [];\n\n  /**\n   * The index of the currently visible and selected step inside the wizardSteps QueryList.\n   * If this wizard contains no steps, currentStepIndex is -1\n   *\n   * Note: Do not modify this field directly.  Instead, use navigation methods:\n   * [[goToStep]], [[goToPreviousStep]], [[goToNextStep]].\n   */\n  public currentStepIndex = -1;\n\n  /**\n   * Constructor\n   */\n  constructor() {\n  }\n\n  /**\n   * Returns true if this wizard uses a horizontal orientation.\n   * The wizard uses a horizontal orientation, iff the navigation bar is shown at the top or bottom of this wizard\n   *\n   * @returns True if this wizard uses a horizontal orientation\n   */\n  @HostBinding('class.horizontal')\n  public get horizontalOrientation(): boolean {\n    return this.navBarLocation === 'top' || this.navBarLocation === 'bottom';\n  }\n\n  /**\n   * Returns true if this wizard uses a vertical orientation.\n   * The wizard uses a vertical orientation, iff the navigation bar is shown at the left or right of this wizard\n   *\n   * @returns True if this wizard uses a vertical orientation\n   */\n  @HostBinding('class.vertical')\n  public get verticalOrientation(): boolean {\n    return this.navBarLocation === 'left' || this.navBarLocation === 'right';\n  }\n\n  /**\n   * Initialization work\n   */\n  public ngAfterContentInit(): void {\n    // add a subscriber to the wizard steps QueryList to listen to changes in the DOM\n    this.wizardStepsQueryList.changes.subscribe(changedWizardSteps => {\n      this.updateWizardSteps(changedWizardSteps.toArray());\n    });\n\n    // initialize the model\n    this.updateWizardSteps(this.wizardStepsQueryList.toArray());\n\n    // finally reset the whole wizard component\n    setTimeout(() => this.reset());\n  }\n\n  /**\n   * The WizardStep object belonging to the currently visible and selected step.\n   * The currentStep is always the currently selected wizard step.\n   * The currentStep can be either completed, if it was visited earlier,\n   * or not completed, if it is visited for the first time or its state is currently out of date.\n   *\n   * If this wizard contains no steps, currentStep is null\n   */\n  public get currentStep(): WizardStep {\n    if (this.hasStep(this.currentStepIndex)) {\n      return this.wizardSteps[this.currentStepIndex];\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * The completeness of the wizard.\n   * If the wizard has been completed, i.e. all steps are either completed or optional, this value is true, otherwise it is false\n   */\n  public get completed(): boolean {\n    return this.wizardSteps.every(step => step.completed || step.optional);\n  }\n\n  /**\n   * An array representation of all wizard steps belonging to this model\n   */\n  public get wizardSteps(): WizardStep[] {\n    return this._wizardSteps;\n  }\n\n  /**\n   * Updates the wizard steps to the new array\n   *\n   * @param wizardSteps The updated wizard steps\n   */\n  private updateWizardSteps(wizardSteps: WizardStep[]): void {\n    // the wizard is currently not in the initialization phase\n    if (this.wizardSteps.length > 0 && this.currentStepIndex > -1) {\n      this.currentStepIndex = wizardSteps.indexOf(this.wizardSteps[this.currentStepIndex]);\n    }\n\n    this._wizardSteps = wizardSteps;\n  }\n\n  /**\n   * The navigation mode used to navigate inside the wizard\n   */\n  public get navigation(): NavigationMode {\n    return this._navigation;\n  }\n\n  /**\n   * Updates the navigation mode for this wizard component\n   *\n   * @param navigation The updated navigation mode\n   */\n  public set navigation(navigation: NavigationMode) {\n    this._navigation = navigation;\n  }\n\n  /**\n   * Checks if a given index `stepIndex` is inside the range of possible wizard steps inside this wizard\n   *\n   * @param stepIndex The to be checked index of a step inside this wizard\n   * @returns True if the given `stepIndex` is contained inside this wizard, false otherwise\n   */\n  public hasStep(stepIndex: number): boolean {\n    return this.wizardSteps.length > 0 && 0 <= stepIndex && stepIndex < this.wizardSteps.length;\n  }\n\n  /**\n   * Checks if this wizard has a previous step, compared to the current step\n   *\n   * @returns True if this wizard has a previous step before the current step\n   */\n  public hasPreviousStep(): boolean {\n    return this.hasStep(this.currentStepIndex - 1);\n  }\n\n  /**\n   * Checks if this wizard has a next step, compared to the current step\n   *\n   * @returns True if this wizard has a next step after the current step\n   */\n  public hasNextStep(): boolean {\n    return this.hasStep(this.currentStepIndex + 1);\n  }\n\n  /**\n   * Checks if this wizard is currently inside its last step\n   *\n   * @returns True if the wizard is currently inside its last step\n   */\n  public isLastStep(): boolean {\n    return this.wizardSteps.length > 0 && this.currentStepIndex === this.wizardSteps.length - 1;\n  }\n\n  /**\n   * Finds the [[WizardStep]] at the given index `stepIndex`.\n   * If no [[WizardStep]] exists at the given index an Error is thrown\n   *\n   * @param stepIndex The given index\n   * @returns The found [[WizardStep]] at the given index `stepIndex`\n   * @throws An `Error` is thrown, if the given index `stepIndex` doesn't exist\n   */\n  public getStepAtIndex(stepIndex: number): WizardStep {\n    if (!this.hasStep(stepIndex)) {\n      throw new Error(`Expected a known step, but got stepIndex: ${stepIndex}.`);\n    }\n\n    return this.wizardSteps[stepIndex];\n  }\n\n  /**\n   * Finds the index of the step with the given `stepId`.\n   * If no step with the given `stepId` exists, `-1` is returned\n   *\n   * @param stepId The given step id\n   * @returns The found index of a step with the given step id, or `-1` if no step with the given id is included in the wizard\n   */\n  public getIndexOfStepWithId(stepId: string): number {\n    return this.wizardSteps.findIndex(step => step.stepId === stepId);\n  }\n\n  /**\n   * Finds the index of the given [[WizardStep]] `step`.\n   * If the given [[WizardStep]] is not contained inside this wizard, `-1` is returned\n   *\n   * @param step The given [[WizardStep]]\n   * @returns The found index of `step` or `-1` if the step is not included in the wizard\n   */\n  public getIndexOfStep(step: WizardStep): number {\n    return this.wizardSteps.indexOf(step);\n  }\n\n  /**\n   * Calculates the correct [[MovingDirection]] value for a given `destinationStep` compared to the `currentStepIndex`.\n   *\n   * @param destinationStep The given destination step\n   * @returns The calculated [[MovingDirection]]\n   */\n  public getMovingDirection(destinationStep: number): MovingDirection {\n    let movingDirection: MovingDirection;\n\n    if (destinationStep > this.currentStepIndex) {\n      movingDirection = MovingDirection.Forwards;\n    } else if (destinationStep < this.currentStepIndex) {\n      movingDirection = MovingDirection.Backwards;\n    } else {\n      movingDirection = MovingDirection.Stay;\n    }\n\n    return movingDirection;\n  }\n\n  /**\n   * Checks, whether a wizard step, as defined by the given destination index, can be transitioned to.\n   *\n   * This method controls navigation by [[goToStep]], [[goToPreviousStep]], and [[goToNextStep]] directives.\n   * Navigation by navigation bar is governed by [[isNavigable]].\n   *\n   * @param destinationIndex The index of the destination step\n   * @returns A [[Promise]] containing `true`, if the destination step can be transitioned to and false otherwise\n   */\n  public canGoToStep(destinationIndex: number): Promise<boolean> {\n    return this.navigation.canGoToStep(this, destinationIndex);\n  }\n\n  /**\n   * Tries to transition to the wizard step, as denoted by the given destination index.\n   *\n   * Note: You do not have to call [[canGoToStep]] before calling [[goToStep]].\n   * The [[canGoToStep]] method will be called automatically.\n   *\n   * @param destinationIndex The index of the destination wizard step, which should be entered\n   * @param preFinalize An event emitter, to be called before the step has been transitioned\n   * @param postFinalize An event emitter, to be called after the step has been transitioned\n   */\n  public goToStep(destinationIndex: number, preFinalize?: EventEmitter<void>, postFinalize?: EventEmitter<void>): void {\n    return this.navigation.goToStep(this, destinationIndex, preFinalize, postFinalize);\n  }\n\n  /**\n   * Tries to transition the wizard to the previous step\n   *\n   * @param preFinalize An event emitter, to be called before the step has been transitioned\n   * @param postFinalize An event emitter, to be called after the step has been transitioned\n   */\n  public goToPreviousStep(preFinalize?: EventEmitter<void>, postFinalize?: EventEmitter<void>): void {\n    return this.navigation.goToStep(this, this.currentStepIndex - 1, preFinalize, postFinalize);\n  }\n\n  /**\n   * Tries to transition the wizard to the next step\n   *\n   * @param preFinalize An event emitter, to be called before the step has been transitioned\n   * @param postFinalize An event emitter, to be called after the step has been transitioned\n   */\n  public goToNextStep(preFinalize?: EventEmitter<void>, postFinalize?: EventEmitter<void>): void {\n    return this.navigation.goToStep(this, this.currentStepIndex + 1, preFinalize, postFinalize);\n  }\n\n  /**\n   * Checks, whether the wizard step, located at the given index, can be navigated to using the navigation bar.\n   *\n   * @param destinationIndex The index of the destination step\n   * @returns True if the step can be navigated to, false otherwise\n   */\n  public isNavigable(destinationIndex: number): boolean {\n    return this.navigation.isNavigable(this, destinationIndex);\n  }\n\n  /**\n   * Resets the state of this wizard.\n   */\n  public reset(): void {\n    this.navigation.reset(this);\n  }\n}\n","import { Component, Input } from '@angular/core';\nimport { WizardCompletionStep } from '../util/wizard-completion-step.interface';\nimport { WizardStep } from '../util/wizard-step.interface';\nimport { WizardComponent } from './wizard.component';\n\n/**\n * The `aw-wizard-navigation-bar` component contains the navigation bar inside a [[WizardComponent]].\n * To correctly display the navigation bar, it's required to set the right css classes for the navigation bar,\n * otherwise it will look like a normal `ul` component.\n *\n * ### Syntax\n *\n * ```html\n * <aw-wizard-navigation-bar></aw-wizard-navigation-bar>\n * ```\n *\n * @author Marc Arndt\n */\n@Component({\n  selector: 'aw-wizard-navigation-bar',\n  templateUrl: 'wizard-navigation-bar.component.html',\n})\nexport class WizardNavigationBarComponent {\n  /**\n   * Constructor\n   *\n   * @param wizard The state the wizard currently resides in\n   */\n  constructor(public wizard: WizardComponent) {\n  }\n\n  /**\n   * Returns all [[WizardStep]]s contained in the wizard\n   *\n   * @returns An array containing all [[WizardStep]]s\n   */\n  get wizardSteps(): Array<WizardStep> {\n    switch (this.wizard.navBarDirection) {\n      case 'right-to-left':\n        return this.wizard.wizardSteps.slice().reverse();\n      case 'left-to-right':\n      default:\n        return this.wizard.wizardSteps;\n    }\n  }\n\n  /**\n   * Returns the number of wizard steps, that need to be displaced in the navigation bar\n   *\n   * @returns The number of wizard steps to be displayed\n   */\n  get numberOfWizardSteps(): number {\n    return this.wizard.wizardSteps.length;\n  }\n\n  /**\n   * Checks, whether a [[WizardStep]] can be marked as `current` in the navigation bar\n   *\n   * @param wizardStep The wizard step to be checked\n   * @returns True if the step can be marked as `current`\n   */\n  public isCurrent(wizardStep: WizardStep): boolean {\n    return wizardStep.selected;\n  }\n\n  /**\n   * Checks, whether a [[WizardStep]] can be marked as `editing` in the navigation bar\n   *\n   * @param wizardStep The wizard step to be checked\n   * @returns True if the step can be marked as `editing`\n   */\n  public isEditing(wizardStep: WizardStep): boolean {\n    return wizardStep.editing;\n  }\n\n  /**\n   * Checks, whether a [[WizardStep]] can be marked as `done` in the navigation bar\n   *\n   * @param wizardStep The wizard step to be checked\n   * @returns True if the step can be marked as `done`\n   */\n  public isDone(wizardStep: WizardStep): boolean {\n    return wizardStep.completed;\n  }\n\n  /**\n   * Checks, whether a [[WizardStep]] can be marked as `optional` in the navigation bar\n   *\n   * @param wizardStep The wizard step to be checked\n   * @returns True if the step can be marked as `optional`\n   */\n  public isOptional(wizardStep: WizardStep): boolean {\n    return wizardStep.optional;\n  }\n\n  /**\n   * Checks, whether a [[WizardStep]] can be marked as `completed` in the navigation bar.\n   *\n   * The `completed` class is only applied to completion steps.\n   *\n   * @param wizardStep The wizard step to be checked\n   * @returns True if the step can be marked as `completed`\n   */\n  public isCompleted(wizardStep: WizardStep): boolean {\n    return wizardStep instanceof WizardCompletionStep && this.wizard.completed;\n  }\n\n  /**\n   * Checks, whether a [[WizardStep]] can be marked as `navigable` in the navigation bar.\n   * A wizard step can be navigated to if:\n   * - the step is currently not selected\n   * - the navigation bar isn't disabled\n   * - the navigation mode allows navigation to the step\n   *\n   * @param wizardStep The wizard step to be checked\n   * @returns True if the step can be marked as navigable\n   */\n  public isNavigable(wizardStep: WizardStep): boolean {\n    return !wizardStep.selected && !this.wizard.disableNavigationBar &&\n      this.wizard.isNavigable(this.wizard.getIndexOfStep(wizardStep));\n  }\n}\n","import {Component, forwardRef} from '@angular/core';\nimport {WizardStep} from '../util/wizard-step.interface';\n\n/**\n * The `aw-wizard-step` component is used to define a normal step inside a wizard.\n *\n * ### Syntax\n *\n * With `stepTitle` and `navigationSymbol` inputs:\n *\n * ```html\n * <aw-wizard-step [stepTitle]=\"step title\" [navigationSymbol]=\"{ symbol: 'symbol', fontFamily: 'font-family' }\"\n *    [canExit]=\"deciding function\" (stepEnter)=\"enter function\" (stepExit)=\"exit function\">\n *    ...\n * </aw-wizard-step>\n * ```\n *\n * With `awWizardStepTitle` and `awWizardStepSymbol` directives:\n *\n * ```html\n * <aw-wizard-step\"\n *    [canExit]=\"deciding function\" (stepEnter)=\"enter function\" (stepExit)=\"exit function\">\n *    <ng-template awWizardStepTitle>\n *        step title\n *    </ng-template>\n *    <ng-template awWizardStepSymbol>\n *        symbol\n *    </ng-template>\n *    ...\n * </aw-wizard-step>\n * ```\n *\n * ### Example\n *\n * With `stepTitle` and `navigationSymbol` inputs:\n *\n * ```html\n * <aw-wizard-step stepTitle=\"Address information\" [navigationSymbol]=\"{ symbol: '&#xf1ba;', fontFamily: 'FontAwesome' }\">\n *    ...\n * </aw-wizard-step>\n * ```\n *\n * With `awWizardStepTitle` and `awWizardStepSymbol` directives:\n *\n * ```html\n * <aw-wizard-step>\n *    <ng-template awWizardStepTitle>\n *        Address information\n *    </ng-template>\n *    <ng-template awWizardStepSymbol>\n *        <i class=\"fa fa-taxi\"></i>\n *    </ng-template>\n * </aw-wizard-step>\n * ```\n *\n * @author Marc Arndt\n */\n@Component({\n  selector: 'aw-wizard-step',\n  templateUrl: 'wizard-step.component.html',\n  providers: [\n    {provide: WizardStep, useExisting: forwardRef(() => WizardStepComponent)}\n  ]\n})\nexport class WizardStepComponent extends WizardStep {\n}\n","import { Directive, EventEmitter, Host, OnInit, Output } from '@angular/core';\nimport { MovingDirection } from '../util/moving-direction.enum';\nimport { WizardCompletionStep } from '../util/wizard-completion-step.interface';\n\n/**\n * The `awEnableBackLinks` directive can be used to allow the user to leave a [[WizardCompletionStep]] after is has been entered.\n *\n * ### Syntax\n *\n * ```html\n * <aw-wizard-completion-step awEnableBackLinks (stepExit)=\"exit function\">\n *     ...\n * </aw-wizard-completion-step>\n * ```\n *\n * ### Example\n *\n * ```html\n * <aw-wizard-completion-step stepTitle=\"Final step\" awEnableBackLinks>\n *     ...\n * </aw-wizard-completion-step>\n * ```\n *\n * @author Marc Arndt\n */\n@Directive({\n  selector: '[awEnableBackLinks]'\n})\nexport class EnableBackLinksDirective implements OnInit {\n  /**\n   * This EventEmitter is called when the step is exited.\n   * The bound method can be used to do cleanup work.\n   */\n  @Output()\n  public stepExit = new EventEmitter<MovingDirection>();\n\n  /**\n   * Constructor\n   *\n   * @param completionStep The wizard completion step, which should be exitable\n   */\n  constructor(@Host() private completionStep: WizardCompletionStep) {\n  }\n\n  /**\n   * Initialization work\n   */\n  public ngOnInit(): void {\n    this.completionStep.canExit = true;\n    this.completionStep.stepExit = this.stepExit;\n  }\n}\n","import {WizardStep} from './wizard-step.interface';\n\n/**\n * An unique identifier of a wizard step\n *\n * @author Marc Arndt\n */\nexport interface StepId {\n  /**\n   * The id of the destination step\n   */\n  stepId: string;\n}\n\n/**\n * Checks whether the given `value` implements the interface [[StepId]].\n *\n * @param value The value to be checked\n * @returns True if the given value implements [[StepId]] and false otherwise\n */\nexport function isStepId(value: any): value is StepId {\n  return value.hasOwnProperty('stepId') && !(value instanceof WizardStep);\n}\n","/**\n * An index of a wizard step.\n * This index is the index of the step inside the wizard.\n * The index is always zero based, i.e. the step with index 0 is the first step of the wizard\n *\n * @author Marc Arndt\n */\nexport interface StepIndex {\n  /**\n   * The index of the destination step\n   */\n  stepIndex: number;\n}\n\n/**\n * Checks whether the given `value` implements the interface [[StepIndex]].\n *\n * @param value The value to be checked\n * @returns True if the given value implements [[StepIndex]] and false otherwise\n */\nexport function isStepIndex(value: any): value is StepIndex {\n  return value.hasOwnProperty('stepIndex');\n}\n","/**\n * An offset between two steps.\n * This offset can be either positive or negative.\n * A positive offset means, that the offset step is after the other step, while a negative offset means,\n * that the offset step is ahead of the other step.\n *\n * @author Marc Arndt\n */\nexport interface StepOffset {\n  /**\n   * The offset to the destination step\n   */\n  stepOffset: number;\n}\n\n/**\n * Checks whether the given `value` implements the interface [[StepOffset]].\n *\n * @param value The value to be checked\n * @returns True if the given value implements [[StepOffset]] and false otherwise\n */\nexport function isStepOffset(value: any): value is StepOffset {\n  return value.hasOwnProperty('stepOffset');\n}\n","import { Directive, EventEmitter, HostListener, Input, Optional, Output } from '@angular/core';\nimport { NavigationMode } from '../navigation/navigation-mode.interface';\nimport { isStepId, StepId } from '../util/step-id.interface';\nimport { isStepIndex, StepIndex } from '../util/step-index.interface';\nimport { isStepOffset, StepOffset } from '../util/step-offset.interface';\nimport { WizardStep } from '../util/wizard-step.interface';\nimport { WizardComponent } from '../components/wizard.component';\n\n/**\n * The `awGoToStep` directive can be used to navigate to a given step.\n * This step can be defined in one of multiple formats\n *\n * ### Syntax\n *\n * With absolute step index:\n *\n * ```html\n * <button [awGoToStep]=\"{ stepIndex: absolute step index }\" (finalize)=\"finalize method\">...</button>\n * ```\n *\n * With unique step id:\n *\n * ```html\n * <button [awGoToStep]=\"{ stepId: 'step id of destination step' }\" (finalize)=\"finalize method\">...</button>\n * ```\n *\n * With a wizard step object:\n *\n * ```html\n * <button [awGoToStep]=\"wizard step object\" (finalize)=\"finalize method\">...</button>\n * ```\n *\n * With an offset to the defining step:\n *\n * ```html\n * <button [awGoToStep]=\"{ stepOffset: offset }\" (finalize)=\"finalize method\">...</button>\n * ```\n *\n * @author Marc Arndt\n */\n@Directive({\n  selector: '[awGoToStep]'\n})\nexport class GoToStepDirective {\n  /**\n   * This [[EventEmitter]] is called directly before the current step is exited during a transition through a component with this directive.\n   */\n  @Output()\n  public preFinalize: EventEmitter<void> = new EventEmitter();\n\n  /**\n   * This [[EventEmitter]] is called directly after the current step is exited during a transition through a component with this directive.\n   */\n  @Output()\n  public postFinalize: EventEmitter<void> = new EventEmitter();\n\n  /**\n   * The destination step, to which the wizard should navigate, after the component, having this directive has been activated.\n   * This destination step can be given either as a [[WizardStep]] containing the step directly,\n   * a [[StepOffset]] between the current step and the `wizardStep`, in which this directive has been used,\n   * or a step index as a number or string\n   */\n  // tslint:disable-next-line:no-input-rename\n  @Input('awGoToStep')\n  public targetStep: WizardStep | StepOffset | StepIndex | StepId;\n\n  /**\n   * Constructor\n   *\n   * @param wizard The wizard component\n   * @param wizardStep The wizard step, which contains this [[GoToStepDirective]]\n   */\n  constructor(private wizard: WizardComponent, @Optional() private wizardStep: WizardStep) {\n  }\n\n  /**\n   * A convenience field for `preFinalize`\n   */\n  public get finalize(): EventEmitter<void> {\n    return this.preFinalize;\n  }\n\n  /**\n   * A convenience name for `preFinalize`\n   *\n   * @param emitter The [[EventEmitter]] to be set\n   */\n  @Output()\n  public set finalize(emitter: EventEmitter<void>) {\n    /* istanbul ignore next */\n    this.preFinalize = emitter;\n  }\n\n  /**\n   * Returns the destination step of this directive as an absolute step index inside the wizard\n   *\n   * @returns The index of the destination step\n   * @throws If `targetStep` is of an unknown type an `Error` is thrown\n   */\n  public get destinationStep(): number {\n    let destinationStep: number;\n\n    if (isStepIndex(this.targetStep)) {\n      destinationStep = this.targetStep.stepIndex;\n    } else if (isStepId(this.targetStep)) {\n      destinationStep = this.wizard.getIndexOfStepWithId(this.targetStep.stepId);\n    } else if (isStepOffset(this.targetStep) && this.wizardStep !== null) {\n      destinationStep = this.wizard.getIndexOfStep(this.wizardStep) + this.targetStep.stepOffset;\n    } else if (this.targetStep instanceof WizardStep) {\n      destinationStep = this.wizard.getIndexOfStep(this.targetStep);\n    } else {\n      throw new Error(`Input 'targetStep' is neither a WizardStep, StepOffset, StepIndex or StepId`);\n    }\n\n    return destinationStep;\n  }\n\n  /**\n   * Listener method for `click` events on the component with this directive.\n   * After this method is called the wizard will try to transition to the `destinationStep`\n   */\n  @HostListener('click')\n  public onClick(): void {\n    this.wizard.goToStep(this.destinationStep, this.preFinalize, this.postFinalize);\n  }\n}\n","import {Directive, EventEmitter, HostListener, Output} from '@angular/core';\nimport {WizardComponent} from '../components/wizard.component';\n\n/**\n * The `awNextStep` directive can be used to navigate to the next step.\n *\n * ### Syntax\n *\n * ```html\n * <button awNextStep (finalize)=\"finalize method\">...</button>\n * ```\n *\n * @author Marc Arndt\n */\n@Directive({\n  selector: '[awNextStep]'\n})\nexport class NextStepDirective {\n  /**\n   * This [[EventEmitter]] is called directly before the current step is exited during a transition through a component with this directive.\n   */\n  @Output()\n  public preFinalize: EventEmitter<void> = new EventEmitter();\n\n  /**\n   * This [[EventEmitter]] is called directly after the current step is exited during a transition through a component with this directive.\n   */\n  @Output()\n  public postFinalize: EventEmitter<void> = new EventEmitter();\n\n  /**\n   * Constructor\n   *\n   * @param wizard The state of the wizard\n   */\n  constructor(private wizard: WizardComponent) {\n  }\n\n  /**\n   * A convenience field for `preFinalize`\n   */\n  public get finalize(): EventEmitter<void> {\n    return this.preFinalize;\n  }\n\n  /**\n   * A convenience name for `preFinalize`\n   *\n   * @param emitter The [[EventEmitter]] to be set\n   */\n  @Output()\n  public set finalize(emitter: EventEmitter<void>) {\n    this.preFinalize = emitter;\n  }\n\n  /**\n   * Listener method for `click` events on the component with this directive.\n   * After this method is called the wizard will try to transition to the next step\n   */\n  @HostListener('click')\n  public onClick(): void {\n    this.wizard.goToNextStep(this.preFinalize, this.postFinalize);\n  }\n}\n","import {Directive, Host, Input, OnInit} from '@angular/core';\nimport {WizardStep} from '../util/wizard-step.interface';\n\n/**\n * The `awOptionalStep` directive can be used to define an optional `wizard-step`.\n * An optional wizard step is a [[WizardStep]] that doesn't need to be completed to transition to later wizard steps.\n *\n * ### Syntax\n *\n * ```html\n * <aw-wizard-step awOptionalStep>\n *     ...\n * </aw-wizard-step>\n * ```\n *\n * ### Example\n *\n * ```html\n * <aw-wizard-step stepTitle=\"Second step\" awOptionalStep>\n *     ...\n * </aw-wizard-step>\n * ```\n *\n * @author Marc Arndt\n */\n@Directive({\n  selector: '[awOptionalStep]'\n})\nexport class OptionalStepDirective implements OnInit {\n\n  // tslint:disable-next-line:no-input-rename\n  @Input('awOptionalStep')\n  public optional = true;\n\n  /**\n   * Constructor\n   *\n   * @param wizardStep The wizard step, which contains this [[OptionalStepDirective]]\n   */\n  constructor(@Host() private wizardStep: WizardStep) {\n  }\n\n  /**\n   * Initialization work\n   */\n  public ngOnInit(): void {\n    // The input receives '' when specified in the template without a value.  In this case, apply the default value (`true`).\n    this.wizardStep.optional = this.optional || this.optional as any === '';\n  }\n}\n","import {Directive, EventEmitter, HostListener, Output} from '@angular/core';\nimport {WizardComponent} from '../components/wizard.component';\n\n/**\n * The `awPreviousStep` directive can be used to navigate to the previous step.\n * Compared to the [[NextStepDirective]] it's important to note, that this directive doesn't contain a `finalize` output method.\n *\n * ### Syntax\n *\n * ```html\n * <button awPreviousStep>...</button>\n * ```\n *\n * @author Marc Arndt\n */\n@Directive({\n  selector: '[awPreviousStep]'\n})\nexport class PreviousStepDirective {\n  /**\n   * This [[EventEmitter]] is called directly before the current step is exited during a transition through a component with this directive.\n   */\n  @Output()\n  public preFinalize: EventEmitter<void> = new EventEmitter();\n\n  /**\n   * This [[EventEmitter]] is called directly after the current step is exited during a transition through a component with this directive.\n   */\n  @Output()\n  public postFinalize: EventEmitter<void> = new EventEmitter();\n\n  /**\n   * Constructor\n   *\n   * @param wizard The state of the wizard\n   */\n  constructor(private wizard: WizardComponent) {\n  }\n\n  /**\n   * A convenience field for `preFinalize`\n   */\n  public get finalize(): EventEmitter<void> {\n    return this.preFinalize;\n  }\n\n  /**\n   * A convenience field for `preFinalize`\n   *\n   * @param emitter The [[EventEmitter]] to be set\n   */\n  @Output()\n  public set finalize(emitter: EventEmitter<void>) {\n    /* istanbul ignore next */\n    this.preFinalize = emitter;\n  }\n\n  /**\n   * Listener method for `click` events on the component with this directive.\n   * After this method is called the wizard will try to transition to the previous step\n   */\n  @HostListener('click')\n  public onClick(): void {\n    this.wizard.goToPreviousStep(this.preFinalize, this.postFinalize);\n  }\n}\n","import {Directive, EventEmitter, HostListener, Output} from '@angular/core';\nimport {WizardComponent} from '../components/wizard.component';\n\n/**\n * The `awResetWizard` directive can be used to reset the wizard to its initial state.\n * This directive accepts an output, which can be used to specify some custom cleanup work during the reset process.\n *\n * ### Syntax\n *\n * ```html\n * <button awResetWizard (finalize)=\"custom reset task\">...</button>\n * ```\n *\n * @author Marc Arndt\n */\n@Directive({\n  selector: '[awResetWizard]'\n})\nexport class ResetWizardDirective {\n  /**\n   * An [[EventEmitter]] containing some tasks to be done, directly before the wizard is being reset\n   */\n  @Output()\n  public finalize: EventEmitter<void> = new EventEmitter();\n\n  /**\n   * Constructor\n   *\n   * @param wizard The wizard component\n   */\n  constructor(private wizard: WizardComponent) {\n  }\n\n  /**\n   * Resets the wizard\n   */\n  @HostListener('click')\n  public onClick(): void {\n    // do some optional cleanup work\n    this.finalize.emit();\n    // reset the wizard to its initial state\n    this.wizard.reset();\n  }\n}\n","import {Directive, Host, OnInit} from '@angular/core';\nimport {WizardStep} from '../util/wizard-step.interface';\n\n/**\n * The `awSelectedStep` directive can be used on a [[WizardStep]] to set it as selected after the wizard initialisation or a reset.\n *\n * ### Syntax\n *\n * ```html\n * <aw-wizard-step stepTitle=\"Step title\" awSelectedStep>\n *     ...\n * </aw-wizard-step>\n * ```\n *\n * @author Marc Arndt\n */\n@Directive({\n  selector: '[awSelectedStep]'\n})\nexport class SelectedStepDirective implements OnInit {\n  /**\n   * Constructor\n   *\n   * @param wizardStep The wizard step, which should be selected by default\n   */\n  constructor(@Host() private wizardStep: WizardStep) {\n  }\n\n  /**\n   * Initialization work\n   */\n  public ngOnInit(): void {\n    this.wizardStep.defaultSelected = true;\n  }\n}\n","import {Directive, forwardRef} from '@angular/core';\nimport {WizardCompletionStep} from '../util/wizard-completion-step.interface';\nimport {WizardStep} from '../util/wizard-step.interface';\n\n/**\n * The `awWizardCompletionStep` directive can be used to define a completion/success step at the end of your wizard\n * After a [[WizardCompletionStep]] has been entered, it has the characteristic that the user is blocked from\n * leaving it again to a previous step.\n * In addition entering a [[WizardCompletionStep]] automatically sets the `wizard`, and all steps inside the `wizard`,\n * as completed.\n *\n * ### Syntax\n *\n * ```html\n * <div awWizardCompletionStep [stepTitle]=\"title of the wizard step\"\n *    [navigationSymbol]=\"{ symbol: 'navigation symbol', fontFamily: 'font-family' }\"\n *    (stepEnter)=\"event emitter to be called when the wizard step is entered\"\n *    (stepExit)=\"event emitter to be called when the wizard step is exited\">\n *    ...\n * </div>\n * ```\n *\n * ### Example\n *\n * ```html\n * <div awWizardCompletionStep stepTitle=\"Step 1\" [navigationSymbol]=\"{ symbol: '1' }\">\n *    ...\n * </div>\n * ```\n *\n * With a navigation symbol from the `font-awesome` font:\n *\n * ```html\n * <div awWizardCompletionStep stepTitle=\"Step 1\" [navigationSymbol]=\"{ symbol: '&#xf1ba;', fontFamily: 'FontAwesome' }\">\n *    ...\n * </div>\n * ```\n *\n * @author Marc Arndt\n */\n@Directive({\n  selector: '[awWizardCompletionStep]',\n  providers: [\n    {provide: WizardStep, useExisting: forwardRef(() => WizardCompletionStepDirective)},\n    {provide: WizardCompletionStep, useExisting: forwardRef(() => WizardCompletionStepDirective)}\n  ]\n})\nexport class WizardCompletionStepDirective extends WizardCompletionStep {\n}\n","import {Directive, forwardRef} from '@angular/core';\nimport {WizardStep} from '../util/wizard-step.interface';\n\n/**\n * The `awWizardStep` directive can be used to define a normal step inside a wizard.\n *\n * ### Syntax\n *\n * With `stepTitle` and `navigationSymbol` inputs:\n *\n * ```html\n * <div awWizardStep [stepTitle]=\"step title\" [navigationSymbol]=\"{ symbol: 'symbol', fontFamily: 'font-family' }\"\n *    [canExit]=\"deciding function\" (stepEnter)=\"enter function\" (stepExit)=\"exit function\">\n *    ...\n * </div>\n * ```\n *\n * With `awWizardStepTitle` and `awWizardStepSymbol` directives:\n *\n * ```html\n * <div awWizardStep [canExit]=\"deciding function\" (stepEnter)=\"enter function\" (stepExit)=\"exit function\">\n *    <ng-template awWizardStepTitle>\n *        step title\n *    </ng-template>\n *    <ng-template awWizardStepSymbol>\n *        symbol\n *    </ng-template>\n *    ...\n * </div>\n * ```\n *\n * ### Example\n *\n * With `stepTitle` and `navigationSymbol` inputs:\n *\n * ```html\n * <div awWizardStep stepTitle=\"Address information\" [navigationSymbol]=\"{ symbol: '&#xf1ba;', fontFamily: 'FontAwesome' }\">\n *    ...\n * </div>\n * ```\n *\n * With `awWizardStepTitle` and `awWizardStepSymbol` directives:\n *\n * ```html\n * <div awWizardStep>\n *    <ng-template awWizardStepTitle>\n *        Address information\n *    </ng-template>\n *    <ng-template awWizardStepSymbol>\n *        <i class=\"fa fa-taxi\"></i>\n *    </ng-template>\n * </div>\n * ```\n *\n * @author Marc Arndt\n */\n@Directive({\n  selector: '[awWizardStep]',\n  providers: [\n    {provide: WizardStep, useExisting: forwardRef(() => WizardStepDirective)}\n  ]\n})\nexport class WizardStepDirective extends WizardStep {\n}\n","import {Directive, Input, OnChanges, SimpleChanges} from '@angular/core';\n\nimport {NavigationMode} from '../navigation/navigation-mode.interface';\nimport {ConfigurableNavigationMode} from '../navigation/configurable-navigation-mode';\nimport {WizardComponent} from '../components/wizard.component';\n\n\n/**\n * The [[awNavigationMode]] directive can be used to customize wizard'd navigation mode.\n *\n * There are several usage options:\n *\n * ### Option 1. Customize the default navigation mode with [[navigateBackward]] and/or [[navigateForward]] inputs.\n *\n * ```html\n * <aw-wizard [awNavigationMode] navigateBackward=\"deny\" navigateForward=\"allow\">...</aw-wizard>\n * ```\n *\n * ### Option 2. Pass in a custom navigation mode\n *\n * ```typescript\n * import { BaseNavigationMode } from 'angular-archwizard'\n *\n * class CustomNavigationMode extends BaseNavigationMode {\n *\n *   // ...\n * }\n * ```\n *\n * ```typescript\n * @Component({\n *   // ...\n * })\n * class MyComponent {\n *\n *   navigationMode = new CustomNavigationMode();\n * }\n * ```\n *\n * ```html\n * <aw-wizard [awNavigationMode]=\"navigationMode\">...</aw-wizard>\n * ```\n *\n * ### Additional Notes\n *\n * - Specifying a custom navigation mode takes priority over [[navigateBackward]] and [[navigateForward]] inputs\n *\n * - Omitting the [[awNavigationMode]] directive or, equally, specifying just [[awNavigationMode]] without\n *   any inputs or parameters causes the wizard to use the default \"strict\" navigation mode equivalent to\n *\n * ```html\n * <aw-wizard [awNavigationMode] navigateBackward=\"deny\" navigateForward=\"allow\">...</aw-wizard>\n * ````\n */\n@Directive({\n  selector: '[awNavigationMode]',\n})\nexport class NavigationModeDirective implements OnChanges {\n\n  /**\n   * Custom navigation mode instance (optional).\n   */\n  @Input()\n  public awNavigationMode: NavigationMode|null;\n\n  /**\n   * A parameter for the default navigation mode.  Controls whether wizard steps before the current step are navigable:\n   *\n   * - `navigateBackward=\"deny\"` -- the steps are not navigable\n   * - `navigateBackward=\"allow\"` -- the steps are navigable\n   */\n  @Input()\n  public navigateBackward: 'allow'|'deny'|null;\n\n  /**\n   * A parameter for the default navigation mode.  Controls whether wizard steps after the current step are navigable:\n   *\n   * - `navigateForward=\"deny\"` -- the steps are not navigable\n   * - `navigateForward=\"allow\"` -- the steps are navigable\n   * - `navigateForward=\"visited\"` -- a step is navigable iff it was already visited before\n   */\n  @Input()\n  public navigateForward: 'allow'|'deny'|'visited'|null;\n\n  constructor(private wizard: WizardComponent) { }\n\n  public ngOnChanges(changes: SimpleChanges): void {\n    this.wizard.navigation = this.getNavigationMode();\n  }\n\n  private getNavigationMode(): NavigationMode {\n    if (this.awNavigationMode) {\n      return this.awNavigationMode;\n    }\n    return new ConfigurableNavigationMode(this.navigateBackward, this.navigateForward);\n  }\n\n}\n","import {Directive, Host, Input, OnInit} from '@angular/core';\nimport {WizardStep} from '../util/wizard-step.interface';\n\n/**\n * The `awCompletedStep` directive can be used to make a wizard step initially completed.\n *\n * Initially completed steps are shown as completed when the wizard is presented to the user.\n *\n * A typical use case is to make a step initially completed if it is automatically filled with some derived/predefined information.\n *\n * ### Syntax\n *\n * ```html\n * <aw-wizard-step awCompletedStep>\n *     ...\n * </aw-wizard-step>\n * ```\n *\n * An optional boolean condition can be specified:\n *\n * ```html\n * <aw-wizard-step [awCompletedStep]=\"shouldBeCompleted\">\n *     ...\n * </aw-wizard-step>\n * ```\n *\n * ### Example\n *\n * ```html\n * <aw-wizard-step stepTitle=\"First step\" [awCompletedStep]=\"firstStepPrefilled\">\n *     ...\n * </aw-wizard-step>\n * ```\n */\n@Directive({\n  selector: '[awCompletedStep]'\n})\nexport class CompletedStepDirective implements OnInit {\n\n  // tslint:disable-next-line:no-input-rename\n  @Input('awCompletedStep')\n  public initiallyCompleted = true;\n\n  /**\n   * Constructor\n   *\n   * @param wizardStep The wizard step, which contains this [[CompletedStepDirective]]\n   */\n  constructor(@Host() private wizardStep: WizardStep) {\n  }\n\n  /**\n   * Initialization work\n   */\n  public ngOnInit(): void {\n    // The input receives '' when specified in the template without a value.  In this case, apply the default value (`true`).\n    this.wizardStep.initiallyCompleted = this.initiallyCompleted || this.initiallyCompleted as any === '';\n  }\n}\n","import {CommonModule} from '@angular/common';\nimport {ModuleWithProviders, NgModule} from '@angular/core';\nimport {WizardCompletionStepComponent} from './components/wizard-completion-step.component';\nimport {WizardNavigationBarComponent} from './components/wizard-navigation-bar.component';\nimport {WizardStepComponent} from './components/wizard-step.component';\nimport {WizardComponent} from './components/wizard.component';\nimport {EnableBackLinksDirective} from './directives/enable-back-links.directive';\nimport {GoToStepDirective} from './directives/go-to-step.directive';\nimport {NextStepDirective} from './directives/next-step.directive';\nimport {OptionalStepDirective} from './directives/optional-step.directive';\nimport {PreviousStepDirective} from './directives/previous-step.directive';\nimport {ResetWizardDirective} from './directives/reset-wizard.directive';\nimport {SelectedStepDirective} from './directives/selected-step.directive';\nimport {WizardCompletionStepDirective} from './directives/wizard-completion-step.directive';\nimport {WizardStepSymbolDirective} from './directives/wizard-step-symbol.directive';\nimport {WizardStepTitleDirective} from './directives/wizard-step-title.directive';\nimport {WizardStepDirective} from './directives/wizard-step.directive';\nimport {NavigationModeDirective} from './directives/navigation-mode.directive';\nimport {CompletedStepDirective} from './directives/completed-step.directive';\n\n\n/**\n * The module defining all the content inside `angular-archwizard`\n *\n * @author Marc Arndt\n */\n@NgModule({\n  declarations: [\n    WizardComponent,\n    WizardStepComponent,\n    WizardNavigationBarComponent,\n    WizardCompletionStepComponent,\n    GoToStepDirective,\n    NextStepDirective,\n    PreviousStepDirective,\n    OptionalStepDirective,\n    WizardStepSymbolDirective,\n    WizardStepTitleDirective,\n    EnableBackLinksDirective,\n    WizardStepDirective,\n    WizardCompletionStepDirective,\n    SelectedStepDirective,\n    ResetWizardDirective,\n    NavigationModeDirective,\n    CompletedStepDirective,\n  ],\n  imports: [\n    CommonModule\n  ],\n  exports: [\n    WizardComponent,\n    WizardStepComponent,\n    WizardNavigationBarComponent,\n    WizardCompletionStepComponent,\n    GoToStepDirective,\n    NextStepDirective,\n    PreviousStepDirective,\n    OptionalStepDirective,\n    WizardStepSymbolDirective,\n    WizardStepTitleDirective,\n    EnableBackLinksDirective,\n    WizardStepDirective,\n    WizardCompletionStepDirective,\n    SelectedStepDirective,\n    ResetWizardDirective,\n    NavigationModeDirective,\n    CompletedStepDirective,\n  ]\n})\nexport class ArchwizardModule {\n  /* istanbul ignore next */\n  public static forRoot(): ModuleWithProviders<ArchwizardModule> {\n    return {\n      ngModule: ArchwizardModule,\n      providers: [\n        // Nothing here yet\n      ]\n    };\n  }\n}\n"]}