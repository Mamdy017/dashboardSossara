/**
 * @license ngx-tabset
 * MIT license
 */

import { Component, ContentChild, ContentChildren, EventEmitter, Input, NgModule, Output, TemplateRef } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

function TabComponent_div_0_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵelementContainer(1, 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.template);
} }
function TabComponent_div_0_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementEnd();
} }
function TabComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵtemplate(1, TabComponent_div_0_div_1_Template, 2, 1, "div", 2);
    ɵngcc0.ɵɵtemplate(2, TabComponent_div_0_div_2_Template, 2, 0, "div", 2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r0.customPaneClass);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.bypassDOM);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r0.bypassDOM);
} }
const _c0 = ["*"];
function TabsetComponent_li_1_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 5);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tab_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(tab_r1.tabSubTitle);
} }
function TabsetComponent_li_1_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 3);
    ɵngcc0.ɵɵlistener("click", function TabsetComponent_li_1_Template_li_click_0_listener() { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r5); const tab_r1 = restoredCtx.$implicit; const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ɵngcc0.ɵɵresetView(ctx_r4.selectTab(tab_r1)); });
    ɵngcc0.ɵɵelementStart(1, "span");
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, TabsetComponent_li_1_span_3_Template, 2, 1, "span", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tab_r1 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("active", tab_r1.active)("disabled", tab_r1.disabled);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(tab_r1.tabTitle);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !!tab_r1.tabSubTitle);
} }
class TabComponent {
    constructor() {
        this.active = false;
        this.disabled = false;
        this.bypassDOM = false;
        this.customPaneClass = '';
    }
}
TabComponent.ɵfac = function TabComponent_Factory(t) { return new (t || TabComponent)(); };
TabComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TabComponent, selectors: [["ngx-tab"]], contentQueries: function TabComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, TemplateRef, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);
    } }, inputs: { active: "active", disabled: "disabled", bypassDOM: "bypassDOM", customPaneClass: "customPaneClass", tabTitle: "tabTitle", tabSubTitle: "tabSubTitle" }, ngContentSelectors: _c0, decls: 1, vars: 1, consts: [["class", "pane", 3, "ngClass", 4, "ngIf"], [1, "pane", 3, "ngClass"], [4, "ngIf"], [3, "ngTemplateOutlet"]], template: function TabComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, TabComponent_div_0_Template, 3, 3, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.active);
    } }, dependencies: [ɵngcc1.NgClass, ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet], encapsulation: 2 });
/** @nocollapse */
TabComponent.ctorParameters = () => [];
TabComponent.propDecorators = {
    "tabTitle": [{ type: Input },],
    "tabSubTitle": [{ type: Input },],
    "active": [{ type: Input },],
    "disabled": [{ type: Input },],
    "bypassDOM": [{ type: Input },],
    "customPaneClass": [{ type: Input },],
    "template": [{ type: ContentChild, args: [TemplateRef,] },],
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TabComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-tab',
                template: `
    <div *ngIf="active"
         class="pane"
         [ngClass]="customPaneClass">
      <div *ngIf="bypassDOM">
        <ng-container [ngTemplateOutlet]="template"></ng-container>
      </div>
      <div *ngIf="!bypassDOM">
        <ng-content></ng-content>
      </div>
    </div>
  `
            }]
    }], function () { return []; }, { active: [{
            type: Input
        }], disabled: [{
            type: Input
        }], bypassDOM: [{
            type: Input
        }], customPaneClass: [{
            type: Input
        }], tabTitle: [{
            type: Input
        }], tabSubTitle: [{
            type: Input
        }], template: [{
            type: ContentChild,
            args: [TemplateRef]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TabsetComponent {
    constructor() {
        this.disableStyle = false;
        this.customNavClass = '';
        this.customTabsClass = '';
        this.onSelect = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // get all active tabs
        const /** @type {?} */ activeTabs = this.tabs.filter((tab) => tab.active);
        // if there is no active tab set, activate the first
        if (activeTabs.length === 0) {
            this.selectTab(this.tabs.first);
        }
    }
    /**
     * @param {?} tabToSelect
     * @return {?}
     */
    selectTab(tabToSelect) {
        if (tabToSelect.disabled === true || tabToSelect.active === true) {
            return;
        }
        // deactivate all tabs
        this.tabs.toArray().forEach((tab) => tab.active = false);
        // activate the tab the user has clicked on.
        tabToSelect.active = true;
        this.onSelect.emit(this.tabs.toArray().indexOf(tabToSelect));
    }
}
TabsetComponent.ɵfac = function TabsetComponent_Factory(t) { return new (t || TabsetComponent)(); };
TabsetComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: TabsetComponent, selectors: [["ngx-tabset"]], contentQueries: function TabsetComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, TabComponent, 4);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabs = _t);
    } }, inputs: { disableStyle: "disableStyle", customNavClass: "customNavClass", customTabsClass: "customTabsClass" }, outputs: { onSelect: "onSelect" }, ngContentSelectors: _c0, decls: 4, vars: 5, consts: [[1, "nav-tabset", 3, "ngClass"], ["class", "nav-tab", 3, "active", "disabled", "click", 4, "ngFor", "ngForOf"], [1, "tabs-container", 3, "ngClass"], [1, "nav-tab", 3, "click"], ["class", "tab-subtitle", 4, "ngIf"], [1, "tab-subtitle"]], template: function TabsetComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "ul", 0);
        ɵngcc0.ɵɵtemplate(1, TabsetComponent_li_1_Template, 4, 6, "li", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("disable-style", ctx.disableStyle);
        ɵngcc0.ɵɵproperty("ngClass", ctx.customNavClass);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.tabs);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ctx.customTabsClass);
    } }, dependencies: [ɵngcc1.NgClass, ɵngcc1.NgForOf, ɵngcc1.NgIf], encapsulation: 2 });
/** @nocollapse */
TabsetComponent.ctorParameters = () => [];
TabsetComponent.propDecorators = {
    "tabs": [{ type: ContentChildren, args: [TabComponent,] },],
    "disableStyle": [{ type: Input },],
    "customNavClass": [{ type: Input },],
    "customTabsClass": [{ type: Input },],
    "onSelect": [{ type: Output },],
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TabsetComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-tabset',
                template: `
    <ul class="nav-tabset"
        [class.disable-style]="disableStyle"
        [ngClass]="customNavClass">
      <li *ngFor="let tab of tabs"
          (click)="selectTab(tab)"
          class="nav-tab"
          [class.active]="tab.active"
          [class.disabled]="tab.disabled">
        <span>{{ tab.tabTitle }}</span>
        <span *ngIf="!!tab.tabSubTitle" class="tab-subtitle">{{ tab.tabSubTitle }}</span>
      </li>
    </ul>
    <div class="tabs-container"
         [ngClass]="customTabsClass">
      <ng-content></ng-content>
    </div>
  `
            }]
    }], function () { return []; }, { disableStyle: [{
            type: Input
        }], customNavClass: [{
            type: Input
        }], customTabsClass: [{
            type: Input
        }], onSelect: [{
            type: Output
        }], tabs: [{
            type: ContentChildren,
            args: [TabComponent]
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TabsModule {
    /**
     * Use in AppModule: new instance of NgxTabset.
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: TabsModule,
            providers: []
        };
    }
    /**
     * Use in features modules with lazy loading: new instance of NgxTabset.
     * @return {?}
     */
    static forChild() {
        return {
            ngModule: TabsModule,
            providers: []
        };
    }
}
TabsModule.ɵfac = function TabsModule_Factory(t) { return new (t || TabsModule)(); };
TabsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: TabsModule });
TabsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [CommonModule] });
/** @nocollapse */
TabsModule.ctorParameters = () => [];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TabsModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    TabComponent,
                    TabsetComponent,
                ],
                exports: [
                    TabComponent,
                    TabsetComponent,
                ],
                imports: [CommonModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TabsModule, { declarations: function () { return [TabComponent, TabsetComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [TabComponent, TabsetComponent]; } }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// Public classes.

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Entry point for all public APIs of the package.
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { TabsetComponent, TabComponent, TabsModule };

//# sourceMappingURL=ngx-tabset.js.map