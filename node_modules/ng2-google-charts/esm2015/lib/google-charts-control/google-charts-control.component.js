import { __awaiter } from "tslib";
import { Component, Input } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "../google-charts-loader.service";
export class GoogleChartsControlComponent {
    constructor(el, loaderService) {
        this.el = el;
        this.loaderService = loaderService;
        this.el = el;
        this.loaderService = loaderService;
    }
    ngOnInit() {
        this.data.component = this;
    }
    ensureInit() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.wrapper) {
                return;
            }
            yield this.loaderService.load({ packages: ['controls'] });
            let opt;
            opt = Object.create(this.data);
            opt.containerId = this.el.nativeElement.querySelector('div');
            this.wrapper = new google.visualization.ControlWrapper(opt);
        });
    }
}
GoogleChartsControlComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: GoogleChartsControlComponent, deps: [{ token: i0.ElementRef }, { token: i1.GoogleChartsLoaderService }], target: i0.ɵɵFactoryTarget.Component });
GoogleChartsControlComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.14", type: GoogleChartsControlComponent, selector: "google-charts-control", inputs: { data: "data" }, ngImport: i0, template: '<div></div>', isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: GoogleChartsControlComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'google-charts-control',
                    template: '<div></div>',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i1.GoogleChartsLoaderService }]; }, propDecorators: { data: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ29vZ2xlLWNoYXJ0cy1jb250cm9sLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL25nMi1nb29nbGUtY2hhcnRzL3NyYy9saWIvZ29vZ2xlLWNoYXJ0cy1jb250cm9sL2dvb2dsZS1jaGFydHMtY29udHJvbC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQVNBLE9BQU8sRUFDTCxTQUFTLEVBQVUsS0FBSyxFQUV6QixNQUFNLGVBQWUsQ0FBQzs7O0FBV3ZCLE1BQU0sT0FBTyw0QkFBNEI7SUFNdkMsWUFBMkIsRUFBYyxFQUNkLGFBQXdDO1FBRHhDLE9BQUUsR0FBRixFQUFFLENBQVk7UUFDZCxrQkFBYSxHQUFiLGFBQWEsQ0FBMkI7UUFDakUsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUM7UUFDYixJQUFJLENBQUMsYUFBYSxHQUFHLGFBQWEsQ0FBQztJQUNyQyxDQUFDO0lBRUQsUUFBUTtRQUNOLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztJQUM3QixDQUFDO0lBRVksVUFBVTs7WUFDckIsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO2dCQUNoQixPQUFPO2FBQ1I7WUFDRCxNQUFNLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEVBQUMsUUFBUSxFQUFFLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ3pELElBQUksR0FBdUMsQ0FBQztZQUM1QyxHQUFHLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDL0IsR0FBRyxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDN0QsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLE1BQU0sQ0FBQyxhQUFhLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzlELENBQUM7S0FBQTs7MEhBekJVLDRCQUE0Qjs4R0FBNUIsNEJBQTRCLHVGQUY3QixhQUFhOzRGQUVaLDRCQUE0QjtrQkFKeEMsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsdUJBQXVCO29CQUNqQyxRQUFRLEVBQUUsYUFBYTtpQkFDeEI7eUlBR2lCLElBQUk7c0JBQW5CLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJkZWNsYXJlIHZhciBnb29nbGU6IGFueTtcblxuZXhwb3J0IGludGVyZmFjZSBHb29nbGVDaGFydHNDb250cm9sSW50ZXJmYWNlIHtcbiAgY29udHJvbFR5cGU6IHN0cmluZztcbiAgb3B0aW9ucz86IG9iamVjdDtcbiAgc3RhdGU/OiBvYmplY3Q7XG4gIGNvbXBvbmVudD86IEdvb2dsZUNoYXJ0c0NvbnRyb2xDb21wb25lbnQ7XG59XG5cbmltcG9ydCB7XG4gIENvbXBvbmVudCwgT25Jbml0LCBJbnB1dCxcbiAgRWxlbWVudFJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgR29vZ2xlQ2hhcnRzTG9hZGVyU2VydmljZSB9IGZyb20gJy4uL2dvb2dsZS1jaGFydHMtbG9hZGVyLnNlcnZpY2UnO1xuXG5pbnRlcmZhY2UgSW50ZXJuYWxHb29nbGVDaGFydHNDb250cm9sT3B0aW9ucyBleHRlbmRzIEdvb2dsZUNoYXJ0c0NvbnRyb2xJbnRlcmZhY2Uge1xuICBjb250YWluZXJJZDogc3RyaW5nO1xufVxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZ29vZ2xlLWNoYXJ0cy1jb250cm9sJyxcbiAgdGVtcGxhdGU6ICc8ZGl2PjwvZGl2PicsXG59KVxuZXhwb3J0IGNsYXNzIEdvb2dsZUNoYXJ0c0NvbnRyb2xDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gIEBJbnB1dCgpIHB1YmxpYyBkYXRhITogR29vZ2xlQ2hhcnRzQ29udHJvbEludGVyZmFjZTtcblxuICBwdWJsaWMgd3JhcHBlcjogYW55O1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsOiBFbGVtZW50UmVmLFxuICAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZSBsb2FkZXJTZXJ2aWNlOiBHb29nbGVDaGFydHNMb2FkZXJTZXJ2aWNlKSB7XG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHRoaXMubG9hZGVyU2VydmljZSA9IGxvYWRlclNlcnZpY2U7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLmRhdGEuY29tcG9uZW50ID0gdGhpcztcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBlbnN1cmVJbml0KCkge1xuICAgIGlmICh0aGlzLndyYXBwZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5sb2FkZXJTZXJ2aWNlLmxvYWQoe3BhY2thZ2VzOiBbJ2NvbnRyb2xzJ10gfSk7XG4gICAgbGV0IG9wdDogSW50ZXJuYWxHb29nbGVDaGFydHNDb250cm9sT3B0aW9ucztcbiAgICBvcHQgPSBPYmplY3QuY3JlYXRlKHRoaXMuZGF0YSk7XG4gICAgb3B0LmNvbnRhaW5lcklkID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2RpdicpO1xuICAgIHRoaXMud3JhcHBlciA9IG5ldyBnb29nbGUudmlzdWFsaXphdGlvbi5Db250cm9sV3JhcHBlcihvcHQpO1xuICB9XG59XG4iXX0=