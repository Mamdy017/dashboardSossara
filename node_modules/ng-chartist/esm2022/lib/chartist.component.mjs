import { Component, ElementRef, EventEmitter, Input, Output, } from "@angular/core";
import { BarChart, LineChart, PieChart, } from "chartist";
import * as i0 from "@angular/core";
/**
 * Angular component which renders Chartist chart.
 *
 * See Chartist {@link https://gionkunz.github.io/chartist-js/api-documentation.html API documentation} and
 * {@link https://gionkunz.github.io/chartist-js/examples.html examples} for more information.
 * ### Example
 ```html
 <x-chartist
   [configuration]="configuration"
   [events]="events"
 ></x-chartist>
 ```
 */
class ChartistComponent {
    elementRef;
    configuration;
    /**
     * Events object where keys are Chartist event names and values are event handler functions.
     *
     * Supported events are: draw, optionsChanged, data, animationBegin, animationEnd, created.
     *
     * Event handler function will receive a data argument which contains event data.
     */
    events;
    /**
     * Event emitted after Chartist chart has been initialized.
     *
     * Event handler function will receive chart instance argument.
     */
    initialized = new EventEmitter();
    chart;
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
    ngOnInit() {
        if (this.configuration.type && this.configuration.data) {
            this.renderChart();
        }
    }
    ngOnChanges(changes) {
        this.update(changes);
    }
    ngOnDestroy() {
        if (this.chart) {
            this.chart.detach();
            this.chart = null;
        }
    }
    renderChart() {
        const nativeElement = this.elementRef.nativeElement;
        const { type, data, options, responsiveOptions } = this.configuration;
        if (type === "Bar") {
            this.chart = new BarChart(nativeElement, data, options, responsiveOptions);
        }
        else if (type === "Line") {
            this.chart = new LineChart(nativeElement, data, options, responsiveOptions);
        }
        else if (type === "Pie") {
            this.chart = new PieChart(nativeElement, data, options, responsiveOptions);
        }
        else {
            throw new Error(`${type} is not a known chart type`);
        }
        if (this.events) {
            this.bindEvents();
        }
        this.initialized.emit(this.chart);
    }
    update(changes) {
        const { type, data, options } = this.configuration;
        if (!type || !data) {
            return;
        }
        const changedConfiguration = changes.configuration
            .currentValue;
        if (!this.chart || changedConfiguration.type !== type) {
            this.renderChart();
        }
        else if ("data" in changedConfiguration ||
            "options" in changedConfiguration) {
            this.chart.update(data, options);
        }
    }
    bindEvents() {
        for (const event of Object.keys(this.events)) {
            this.chart.on(event, this.events[event]);
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.9", ngImport: i0, type: ChartistComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.9", type: ChartistComponent, selector: "x-chartist", inputs: { configuration: "configuration", events: "events" }, outputs: { initialized: "initialized" }, usesOnChanges: true, ngImport: i0, template: "", isInline: true, styles: [":host{display:block}\n"] });
}
export { ChartistComponent };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.9", ngImport: i0, type: ChartistComponent, decorators: [{
            type: Component,
            args: [{ selector: "x-chartist", template: "", styles: [":host{display:block}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { configuration: [{
                type: Input
            }], events: [{
                type: Input
            }], initialized: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhcnRpc3QuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmctY2hhcnRpc3Qvc3JjL2xpYi9jaGFydGlzdC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLEtBQUssRUFJTCxNQUFNLEdBRVAsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUNMLFFBQVEsRUFHUixTQUFTLEVBR1QsUUFBUSxHQUlULE1BQU0sVUFBVSxDQUFDOztBQXFDbEI7Ozs7Ozs7Ozs7OztHQVlHO0FBQ0gsTUFXYSxpQkFBaUI7SUF3QlI7SUF0QnBCLGFBQWEsQ0FBZ0I7SUFFN0I7Ozs7OztPQU1HO0lBRUgsTUFBTSxDQUFhO0lBRW5COzs7O09BSUc7SUFFSCxXQUFXLEdBQUcsSUFBSSxZQUFZLEVBQWMsQ0FBQztJQUU3QyxLQUFLLENBQWE7SUFFbEIsWUFBb0IsVUFBc0I7UUFBdEIsZUFBVSxHQUFWLFVBQVUsQ0FBWTtJQUFHLENBQUM7SUFFOUMsUUFBUTtRQUNOLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUU7WUFDdEQsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQ3BCO0lBQ0gsQ0FBQztJQUVELFdBQVcsQ0FBQyxPQUFzQjtRQUNoQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ2QsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUNwQixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztTQUNuQjtJQUNILENBQUM7SUFFRCxXQUFXO1FBQ1QsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUM7UUFDcEQsTUFBTSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQztRQUV0RSxJQUFJLElBQUksS0FBSyxLQUFLLEVBQUU7WUFDbEIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLFFBQVEsQ0FDdkIsYUFBYSxFQUNiLElBQUksRUFDSixPQUFPLEVBQ1AsaUJBQWlCLENBQ2xCLENBQUM7U0FDSDthQUFNLElBQUksSUFBSSxLQUFLLE1BQU0sRUFBRTtZQUMxQixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksU0FBUyxDQUN4QixhQUFhLEVBQ2IsSUFBSSxFQUNKLE9BQU8sRUFDUCxpQkFBaUIsQ0FDbEIsQ0FBQztTQUNIO2FBQU0sSUFBSSxJQUFJLEtBQUssS0FBSyxFQUFFO1lBQ3pCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxRQUFRLENBQ3ZCLGFBQWEsRUFDYixJQUFJLEVBQ0osT0FBTyxFQUNQLGlCQUFpQixDQUNsQixDQUFDO1NBQ0g7YUFBTTtZQUNMLE1BQU0sSUFBSSxLQUFLLENBQUMsR0FBRyxJQUFJLDRCQUE0QixDQUFDLENBQUM7U0FDdEQ7UUFFRCxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDZixJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7U0FDbkI7UUFFRCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVELE1BQU0sQ0FBQyxPQUFzQjtRQUMzQixNQUFNLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO1FBRW5ELElBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDbEIsT0FBTztTQUNSO1FBRUQsTUFBTSxvQkFBb0IsR0FBRyxPQUFPLENBQUMsYUFBYTthQUMvQyxZQUE2QixDQUFDO1FBRWpDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLG9CQUFvQixDQUFDLElBQUksS0FBSyxJQUFJLEVBQUU7WUFDckQsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQ3BCO2FBQU0sSUFDTCxNQUFNLElBQUksb0JBQW9CO1lBQzlCLFNBQVMsSUFBSSxvQkFBb0IsRUFDakM7WUFDQSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDbEM7SUFDSCxDQUFDO0lBRUQsVUFBVTtRQUNSLEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDNUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztTQUMxQztJQUNILENBQUM7dUdBdkdVLGlCQUFpQjsyRkFBakIsaUJBQWlCLDhLQVRsQixFQUFFOztTQVNELGlCQUFpQjsyRkFBakIsaUJBQWlCO2tCQVg3QixTQUFTOytCQUNFLFlBQVksWUFDWixFQUFFO2lHQVdaLGFBQWE7c0JBRFosS0FBSztnQkFXTixNQUFNO3NCQURMLEtBQUs7Z0JBU04sV0FBVztzQkFEVixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPdXRwdXQsXG4gIFNpbXBsZUNoYW5nZXMsXG59IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQge1xuICBCYXJDaGFydCxcbiAgQmFyQ2hhcnREYXRhLFxuICBCYXJDaGFydE9wdGlvbnMsXG4gIExpbmVDaGFydCxcbiAgTGluZUNoYXJ0RGF0YSxcbiAgTGluZUNoYXJ0T3B0aW9ucyxcbiAgUGllQ2hhcnQsXG4gIFBpZUNoYXJ0RGF0YSxcbiAgUGllQ2hhcnRPcHRpb25zLFxuICBSZXNwb25zaXZlT3B0aW9ucyxcbn0gZnJvbSBcImNoYXJ0aXN0XCI7XG5cbnR5cGUgQ2hhcnRUeXBlcyA9IEJhckNoYXJ0IHwgTGluZUNoYXJ0IHwgUGllQ2hhcnQ7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFyQ2hhcnRDb25maWd1cmF0aW9uIHtcbiAgdHlwZTogXCJCYXJcIjtcbiAgZGF0YTogQmFyQ2hhcnREYXRhO1xuICBvcHRpb25zPzogQmFyQ2hhcnRPcHRpb25zO1xuICByZXNwb25zaXZlT3B0aW9ucz86IFJlc3BvbnNpdmVPcHRpb25zPEJhckNoYXJ0T3B0aW9ucz47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGluZUNoYXJ0Q29uZmlndXJhdGlvbiB7XG4gIHR5cGU6IFwiTGluZVwiO1xuICBkYXRhOiBMaW5lQ2hhcnREYXRhO1xuICBvcHRpb25zPzogTGluZUNoYXJ0T3B0aW9ucztcbiAgcmVzcG9uc2l2ZU9wdGlvbnM/OiBSZXNwb25zaXZlT3B0aW9uczxMaW5lQ2hhcnRPcHRpb25zPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQaWVDaGFydENvbmZpZ3VyYXRpb24ge1xuICB0eXBlOiBcIlBpZVwiO1xuICBkYXRhOiBQaWVDaGFydERhdGE7XG4gIG9wdGlvbnM/OiBQaWVDaGFydE9wdGlvbnM7XG4gIHJlc3BvbnNpdmVPcHRpb25zPzogUmVzcG9uc2l2ZU9wdGlvbnM8UGllQ2hhcnRPcHRpb25zPjtcbn1cblxuZXhwb3J0IHR5cGUgQ29uZmlndXJhdGlvbiA9XG4gIHwgQmFyQ2hhcnRDb25maWd1cmF0aW9uXG4gIHwgTGluZUNoYXJ0Q29uZmlndXJhdGlvblxuICB8IFBpZUNoYXJ0Q29uZmlndXJhdGlvbjtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGNoYXJ0IGV2ZW50cy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGFydEV2ZW50IHtcbiAgW2V2ZW50TmFtZTogc3RyaW5nXTogKGRhdGE6IHVua25vd24pID0+IHZvaWQ7XG59XG5cbi8qKlxuICogQW5ndWxhciBjb21wb25lbnQgd2hpY2ggcmVuZGVycyBDaGFydGlzdCBjaGFydC5cbiAqXG4gKiBTZWUgQ2hhcnRpc3Qge0BsaW5rIGh0dHBzOi8vZ2lvbmt1bnouZ2l0aHViLmlvL2NoYXJ0aXN0LWpzL2FwaS1kb2N1bWVudGF0aW9uLmh0bWwgQVBJIGRvY3VtZW50YXRpb259IGFuZFxuICoge0BsaW5rIGh0dHBzOi8vZ2lvbmt1bnouZ2l0aHViLmlvL2NoYXJ0aXN0LWpzL2V4YW1wbGVzLmh0bWwgZXhhbXBsZXN9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogIyMjIEV4YW1wbGVcbiBgYGBodG1sXG4gPHgtY2hhcnRpc3RcbiAgIFtjb25maWd1cmF0aW9uXT1cImNvbmZpZ3VyYXRpb25cIlxuICAgW2V2ZW50c109XCJldmVudHNcIlxuID48L3gtY2hhcnRpc3Q+XG4gYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogXCJ4LWNoYXJ0aXN0XCIsXG4gIHRlbXBsYXRlOiBcIlwiLFxuICBzdHlsZXM6IFtcbiAgICBgXG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgfVxuICAgIGAsXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIENoYXJ0aXN0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gIEBJbnB1dCgpXG4gIGNvbmZpZ3VyYXRpb246IENvbmZpZ3VyYXRpb247XG5cbiAgLyoqXG4gICAqIEV2ZW50cyBvYmplY3Qgd2hlcmUga2V5cyBhcmUgQ2hhcnRpc3QgZXZlbnQgbmFtZXMgYW5kIHZhbHVlcyBhcmUgZXZlbnQgaGFuZGxlciBmdW5jdGlvbnMuXG4gICAqXG4gICAqIFN1cHBvcnRlZCBldmVudHMgYXJlOiBkcmF3LCBvcHRpb25zQ2hhbmdlZCwgZGF0YSwgYW5pbWF0aW9uQmVnaW4sIGFuaW1hdGlvbkVuZCwgY3JlYXRlZC5cbiAgICpcbiAgICogRXZlbnQgaGFuZGxlciBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgYSBkYXRhIGFyZ3VtZW50IHdoaWNoIGNvbnRhaW5zIGV2ZW50IGRhdGEuXG4gICAqL1xuICBASW5wdXQoKVxuICBldmVudHM6IENoYXJ0RXZlbnQ7XG5cbiAgLyoqXG4gICAqIEV2ZW50IGVtaXR0ZWQgYWZ0ZXIgQ2hhcnRpc3QgY2hhcnQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG4gICAqXG4gICAqIEV2ZW50IGhhbmRsZXIgZnVuY3Rpb24gd2lsbCByZWNlaXZlIGNoYXJ0IGluc3RhbmNlIGFyZ3VtZW50LlxuICAgKi9cbiAgQE91dHB1dCgpXG4gIGluaXRpYWxpemVkID0gbmV3IEV2ZW50RW1pdHRlcjxDaGFydFR5cGVzPigpO1xuXG4gIGNoYXJ0OiBDaGFydFR5cGVzO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZikge31cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLnR5cGUgJiYgdGhpcy5jb25maWd1cmF0aW9uLmRhdGEpIHtcbiAgICAgIHRoaXMucmVuZGVyQ2hhcnQoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgdGhpcy51cGRhdGUoY2hhbmdlcyk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jaGFydCkge1xuICAgICAgdGhpcy5jaGFydC5kZXRhY2goKTtcbiAgICAgIHRoaXMuY2hhcnQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlckNoYXJ0KCkge1xuICAgIGNvbnN0IG5hdGl2ZUVsZW1lbnQgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICBjb25zdCB7IHR5cGUsIGRhdGEsIG9wdGlvbnMsIHJlc3BvbnNpdmVPcHRpb25zIH0gPSB0aGlzLmNvbmZpZ3VyYXRpb247XG5cbiAgICBpZiAodHlwZSA9PT0gXCJCYXJcIikge1xuICAgICAgdGhpcy5jaGFydCA9IG5ldyBCYXJDaGFydChcbiAgICAgICAgbmF0aXZlRWxlbWVudCxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgcmVzcG9uc2l2ZU9wdGlvbnMsXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJMaW5lXCIpIHtcbiAgICAgIHRoaXMuY2hhcnQgPSBuZXcgTGluZUNoYXJ0KFxuICAgICAgICBuYXRpdmVFbGVtZW50LFxuICAgICAgICBkYXRhLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICByZXNwb25zaXZlT3B0aW9ucyxcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcIlBpZVwiKSB7XG4gICAgICB0aGlzLmNoYXJ0ID0gbmV3IFBpZUNoYXJ0KFxuICAgICAgICBuYXRpdmVFbGVtZW50LFxuICAgICAgICBkYXRhLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICByZXNwb25zaXZlT3B0aW9ucyxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0eXBlfSBpcyBub3QgYSBrbm93biBjaGFydCB0eXBlYCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZXZlbnRzKSB7XG4gICAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRpYWxpemVkLmVtaXQodGhpcy5jaGFydCk7XG4gIH1cblxuICB1cGRhdGUoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIGNvbnN0IHsgdHlwZSwgZGF0YSwgb3B0aW9ucyB9ID0gdGhpcy5jb25maWd1cmF0aW9uO1xuXG4gICAgaWYgKCF0eXBlIHx8ICFkYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hhbmdlZENvbmZpZ3VyYXRpb24gPSBjaGFuZ2VzLmNvbmZpZ3VyYXRpb25cbiAgICAgIC5jdXJyZW50VmFsdWUgYXMgQ29uZmlndXJhdGlvbjtcblxuICAgIGlmICghdGhpcy5jaGFydCB8fCBjaGFuZ2VkQ29uZmlndXJhdGlvbi50eXBlICE9PSB0eXBlKSB7XG4gICAgICB0aGlzLnJlbmRlckNoYXJ0KCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIFwiZGF0YVwiIGluIGNoYW5nZWRDb25maWd1cmF0aW9uIHx8XG4gICAgICBcIm9wdGlvbnNcIiBpbiBjaGFuZ2VkQ29uZmlndXJhdGlvblxuICAgICkge1xuICAgICAgdGhpcy5jaGFydC51cGRhdGUoZGF0YSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgYmluZEV2ZW50cygpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKHRoaXMuZXZlbnRzKSkge1xuICAgICAgdGhpcy5jaGFydC5vbihldmVudCwgdGhpcy5ldmVudHNbZXZlbnRdKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==